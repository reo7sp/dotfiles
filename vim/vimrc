set nocompatible
let g:loaded_netrwPlugin = 1
let g:loaded_netrw = 1

let mapleader = ","


" plugins
call plug#begin('~/.vim/bundle')

" " generic
if ! has('nvim')
  Plug 'tpope/vim-sensible'
endif
if ! has('nvim')
  Plug 'Shougo/vimproc.vim', {'do': 'make'}
endif
if has('nvim')
  Plug 'nvim-lua/plenary.nvim'
  Plug 'nvimtools/hydra.nvim'
  Plug 'kkharji/sqlite.lua'
endif
Plug 'tpope/vim-repeat'

" " editing
if has('nvim')
  Plug 'neovim/nvim-lspconfig'
  Plug 'williamboman/mason.nvim'
  Plug 'williamboman/mason-lspconfig.nvim'
  Plug 'hrsh7th/nvim-cmp'
  Plug 'hrsh7th/cmp-nvim-lsp'
  Plug 'hrsh7th/cmp-buffer'
  Plug 'hrsh7th/cmp-path'
  Plug 'hrsh7th/cmp-nvim-lsp-signature-help'
  Plug 'hrsh7th/cmp-cmdline'
  Plug 'L3MON4D3/LuaSnip'
  Plug 'saadparwaiz1/cmp_luasnip'
  Plug 'rafamadriz/friendly-snippets'
else
  Plug 'vim-scripts/AutoComplPop'
endif
if v:version >= 801
  Plug 'cohama/lexima.vim'
else
  Plug 'Raimondi/delimitMate'
end
Plug 'alvan/vim-closetag'
Plug 'wellle/targets.vim'
if has('nvim')
  Plug 'kylechui/nvim-surround'
else
  Plug 'tpope/vim-surround'
endif
Plug 'romainl/vim-cool'
Plug 'ConradIrwin/vim-bracketed-paste'
Plug 'vim-scripts/file-line'
Plug 'pbrisbin/vim-mkdir'
Plug 'farmergreg/vim-lastplace'
if has('nvim')
  Plug 'okuuva/auto-save.nvim'
else
  Plug '907th/vim-auto-save'
endif
Plug 'tpope/vim-sleuth'
Plug 'ntpeters/vim-better-whitespace'
if has('nvim')
  Plug 'gbprod/yanky.nvim'
  Plug 'debugloop/telescope-undo.nvim'
else
  Plug 'maxbrunsfeld/vim-yankstack'
endif
if has('nvim')
  Plug 'numToStr/Comment.nvim'
else
  Plug 'scrooloose/nerdcommenter'
endif
if has('nvim')
  Plug 'johmsalas/text-case.nvim'
  Plug 'echasnovski/mini.align'
  Plug 'Wansmer/treesj'
endif
if has('nvim')
  Plug 'smoka7/multicursors.nvim'
endif

" " navigation
Plug 'justinmk/vim-sneak'
Plug 'tpope/vim-unimpaired'
Plug 'moll/vim-bbye'
Plug 'vim-scripts/BufOnly.vim'
if has('nvim')
  Plug 'nvim-telescope/telescope.nvim', {'tag': '0.1.8'}
  Plug 'nvim-telescope/telescope-fzf-native.nvim', {'do': 'make'}
  Plug 'smartpde/telescope-recent-files'
  Plug 'nvim-telescope/telescope-live-grep-args.nvim'
  Plug 'princejoogie/dir-telescope.nvim'
  Plug 'jmacadie/telescope-hierarchy.nvim'
endif
if has('nvim')
  Plug 'folke/trouble.nvim'
endif
if has('nvim')
  Plug 'nvim-tree/nvim-tree.lua'
endif
if has('nvim')
  Plug 'stevearc/aerial.nvim'
endif
if has('nvim')
  Plug 'ahmedkhalf/project.nvim'
endif

" " appearance
if has('nvim')
  Plug 'rebelot/kanagawa.nvim'
  Plug 'sainnhe/sonokai'
else
  Plug 'sainnhe/sonokai'
end
if has('nvim')
  Plug 'nvim-lualine/lualine.nvim'
else
  Plug 'vim-airline/vim-airline'
endif
if has('nvim')
  Plug 'akinsho/bufferline.nvim'
  Plug 'tiagovla/scope.nvim'
  Plug 'LukasPietzschmann/telescope-tabs'
else
  Plug 'ap/vim-buftabline'
endif
if has('nvim')
  Plug 'yorickpeterse/nvim-pqf'
endif
if has('nvim')
  Plug 'j-hui/fidget.nvim'
endif
if has('nvim')
  Plug 'lewis6991/gitsigns.nvim'
  Plug 'akinsho/git-conflict.nvim'
else
  Plug 'airblade/vim-gitgutter'
endif
if has('nvim')
  Plug 'Maan2003/lsp_lines.nvim'
endif
if has('nvim')
  Plug 'RRethy/vim-illuminate'
endif
let g:polyglot_disabled = ['sensible', 'autoindent']
Plug 'sheerun/vim-polyglot'
if has('nvim')
  Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
  Plug 'nvim-treesitter/nvim-treesitter-textobjects'
endif
Plug 'Vimjas/vim-python-pep8-indent', {'for': 'python'}
Plug 'johejo/gomod.vim'
Plug 'HiPhish/jinja.vim'

" " commands
if has('nvim')
  Plug 'folke/which-key.nvim'
else
  Plug 'liuchengxu/vim-which-key'
endif
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive', {'on': ['Git', 'Flog', 'Flogsplit']}
Plug 'rbong/vim-flog', {'on': ['Git', 'Flog', 'Flogsplit']}
if has('nvim')
  Plug 'sindrets/diffview.nvim', {'on': ['DiffviewOpen', 'DiffviewFileHistory']}
endif
if has('nvim')
  Plug 'nvim-pack/nvim-spectre', {'on': 'Spectre'}
endif
if has('nvim')
  Plug 'stevearc/oil.nvim'
endif

call plug#end()


" colors
if has('termguicolors')
  set termguicolors
endif

if has('nvim')
  set cmdheight=0
  lua require('kanagawa').setup({compile = true, theme = 'dragon'})
  colorscheme kanagawa-dragon
else
  let g:sonokai_enable_italic = 1
  let g:sonokai_float_style = 'dim'
  let g:airline_theme = 'sonokai'
  colorscheme sonokai
endif


" plugin settings
" " hrsh7th/nvim-cmp
function! InitNvimCmp() abort
  lua << EOF
  local lspconfig_defaults = require('lspconfig').util.default_config
  lspconfig_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lspconfig_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )

  require('mason').setup({})

  require('mason-lspconfig').setup({
    ensure_installed = {
      'cmake',
      'bashls',
      'cssls',
      'dockerls',
      'gopls',
      'html',
      'ts_ls',
      'jsonls',
      'lua_ls',
      'nginx_language_server',
      'vacuum',
      'perlnavigator',
      'puppet',
      'pyright',
      'yamlls',
    },
    handlers = {
      function(server_name)
        require('lspconfig')[server_name].setup({})
      end,
    }
  })

  require('luasnip.loaders.from_vscode').lazy_load()

  local cmp = require('cmp')
  local luasnip = require('luasnip')
  cmp.setup({
    sources = {
      {name = 'path'},
      {name = 'nvim_lsp'},
      {name = 'luasnip', keyword_length = 2},
      {name = 'buffer', keyword_length = 3},
      {name = 'nvim_lsp_signature_help'},
    },
    preselect = 'none',
    completion = {
      completeopt = 'menu,menuone,noinsert,noselect'
    },
    snippet = {
      expand = function(args)
        require('luasnip').lsp_expand(args.body)
      end,
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-d>'] = cmp.mapping(cmp.mapping.scroll_docs(4), {'i', 'c'}),
      ['<C-u>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), {'i', 'c'}),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.close(),
      ['<CR>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          if luasnip.expandable() then
            luasnip.expand()
          else
            cmp.confirm({ select = true })
          end
        else
          fallback()
        end
      end),
      ['<Tab>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          local entry = cmp.get_selected_entry()
          if not entry then
            cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
          end
          cmp.confirm()
        elseif luasnip.expand_or_jumpable() then
          luasnip.expand_or_jump()
        else
          fallback()
        end
      end, { 'i', 's' }),
    }),
  })
  cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      {
        name = 'cmdline',
        option = {
          ignore_cmds = { 'Man', '!' }
        }
      }
    }),
    matching = { disallow_symbol_nonprefix_matching = false }
  })
EOF

  augroup NvimCmp
  autocmd!
  autocmd FileType TelescopePrompt lua require('cmp').setup.buffer({ enabled = false })
  augroup END

  nnoremap gd <cmd>lua require('telescope.builtin').lsp_definitions({fname_width = 60})<cr>
  nnoremap gD <cmd>lua require('telescope.builtin').lsp_implementations({fname_width = 60})<cr>
  nnoremap gi <cmd>lua require('telescope.builtin').lsp_implementations({fname_width = 60})<cr>
  nnoremap gy <cmd>lua require('telescope.builtin').lsp_type_definitions({fname_width = 60})<cr>
  nnoremap gr <cmd>lua require('telescope.builtin').lsp_references({fname_width = 60})<cr>
  nnoremap gh <cmd>Telescope hierarchy theme=ivy disable_devicons=true<cr>
  nnoremap go <cmd>lua vim.lsp.buf.hover()<cr>
  nnoremap K <cmd>lua vim.lsp.buf.hover()<cr>
  nnoremap gp <cmd>lua vim.diagnostic.open_float()<cr>
  nnoremap gq <cmd>lua vim.lsp.buf.code_action()<cr>
  nnoremap <leader>lr <cmd>lua vim.lsp.buf.rename()<cr>
  nnoremap <leader>lf <cmd>lua vim.lsp.buf.format({async = true})<cr>
  xnoremap <leader>lf <cmd>lua vim.lsp.buf.format({async = true})<cr>
  nnoremap <leader>lc <cmd>lua vim.lsp.buf.code_action()<cr>
  nnoremap <leader>lq <cmd>lua vim.lsp.buf.code_action()<cr>
  nnoremap [p <cmd>lua vim.diagnostic.goto_prev({float=false})<cr>
  nnoremap ]p <cmd>lua vim.diagnostic.goto_next({float=false})<cr>
endfunction

if has('nvim')
  call InitNvimCmp()
endif

" " kylechui/nvim-surround
function! InitNvimSurround() abort
  lua require('nvim-surround').setup()
endfunction

if has('nvim')
  call InitNvimSurround()
endif

" " okuuva/auto-save.nvim or 907th/vim-auto-save
function! InitAutosaveNvim() abort
  lua << EOF
  require('auto-save').setup({
    condition = function(buf)
      local filetype = vim.fn.getbufvar(buf, "&filetype")
      if vim.list_contains({ "oil" }, filetype) then
        return false
      end
      return true
    end
  })
EOF
endfunction

function! InitAutosaveVim() abort
  let g:auto_save = 1
  let g:auto_save_silent = 1
endfunction

if has('nvim')
  call InitAutosaveNvim()
else
  call InitAutosaveVim()
endif

" " ntpeters/vim-better-whitespace
function! InitBetterWhitespace() abort
  let g:strip_whitespace_on_save = 1
  let g:strip_only_modified_lines = 1
  let g:strip_whitespace_confirm = 0
  let g:strip_max_file_size = 99999

  nnoremap ]w :NextTrailingWhitespace<CR>
  nnoremap [w :PrevTrailingWhitespace<CR>
endfunction

call InitBetterWhitespace()

" " gbprod/yanky.nvim or maxbrunsfeld/vim-yankstack
function! InitYanky() abort
  lua << EOF
  require('yanky').setup({
    ring = {
      storage = 'memory',
    }
  })

  vim.keymap.set({"n","x"}, "p", "<Plug>(YankyPutAfter)")
  vim.keymap.set({"n","x"}, "P", "<Plug>(YankyPutBefore)")
  vim.keymap.set("n", "[y", "<Plug>(YankyPreviousEntry)")
  vim.keymap.set("n", "]y", "<Plug>(YankyNextEntry)")
  vim.keymap.set("n", ">p", "<Plug>(YankyPutIndentAfterShiftRight)")
  vim.keymap.set("n", "<p", "<Plug>(YankyPutIndentAfterShiftLeft)")
  vim.keymap.set("n", ">P", "<Plug>(YankyPutIndentBeforeShiftRight)")
  vim.keymap.set("n", "<P", "<Plug>(YankyPutIndentBeforeShiftLeft)")
  vim.keymap.set("n", "=p", "<Plug>(YankyPutAfterFilter)")
  vim.keymap.set("n", "=P", "<Plug>(YankyPutBeforeFilter)")
EOF
endfunction

function! InitYankStack() abort
  let g:yankstack_map_keys = 0

  nnoremap ]y <Plug>yankstack_substitute_older_paste
  nnoremap [y <Plug>yankstack_substitute_newer_paste
endfunction

if has('nvim')
  call InitYanky()
else
  call InitYankStack()
endif

" " numToStr/Comment.nvim or scrooloose/nerdcommenter
function! InitComment() abort
  lua require('Comment').setup()

  nnoremap <C-/> <Plug>(comment_toggle_linewise_current)
  nnoremap <C-_> <Plug>(comment_toggle_linewise_current)
  xnoremap <C-/> <Plug>(comment_toggle_linewise_visual)
  xnoremap <C-_> <Plug>(comment_toggle_linewise_visual)
endfunction

function! InitNerdCommenter() abort
  nnoremap <C-/> <Plug>NERDCommenterToggle
  nnoremap <C-_> <Plug>NERDCommenterToggle
  vnoremap <C-/> <Plug>NERDCommenterToggle<CR>gv
  vnoremap <C-_> <Plug>NERDCommenterToggle<CR>gv
endfunction

if has('nvim')
  call InitComment()
else
  call InitNerdCommenter()
end

" " johmsalas/text-case.nvim
function! InitTextCase() abort
  lua << EOF
  require('textcase').setup({
    prefix = 'gt',
  })
EOF

  nnoremap gt/ <cmd>TextCaseOpenTelescope<CR>
  vnoremap gt/ <cmd>TextCaseOpenTelescope<CR>
endfunction

if has('nvim')
  call InitTextCase()
endif

" " echasnovski/mini.align
function! InitMiniAlign() abort
  lua require('mini.align').setup()
endfunction

if has('nvim')
  call InitMiniAlign()
endif

" " Wansmer/treesj
function! InitTreeSJ() abort
  lua << EOF
  require('treesj').setup({
    use_default_keymaps = false,
    max_join_length = 9999,
  })
EOF

  nnoremap gs <cmd>lua require('treesj').toggle()<cr>
  nnoremap gS <cmd>lua require('treesj').toggle({ split = { recursive = true } })<cr>
endfunction

if has('nvim')
  call InitTreeSJ()
endif

" " smoka7/multicursors.nvim
function! InitMulticursors() abort
  lua require('multicursors').setup({})

  nnoremap <leader>n <cmd>MCstart<cr>
  vnoremap <leader>n <cmd>MCstart<cr>
endfunction

if has('nvim')
  call InitMulticursors()
endif

" " justinmk/vim-sneak
function! InitSneak() abort
  let g:sneak#use_ic_scs = 1

  map f <Plug>Sneak_f
  map F <Plug>Sneak_F
  map t <Plug>Sneak_t
  map T <Plug>Sneak_T
endfunction

call InitSneak()

" " moll/vim-bbye
function! InitBbye() abort
  cnoreabbrev bq Bdelete
endfunction

call InitBbye()

" " vim-scripts/BufOnly.vim
function! InitBufOnly() abort
  cnoreabbrev bqo BufOnly
  cnoreabbrev bo BufOnly
endfunction

call InitBufOnly()

" " nvim-telescope/telescope.nvim
function! InitTelescope() abort
  lua << EOF
  require('telescope').setup({
    defaults = vim.tbl_extend(
      'force',
      require('telescope.themes').get_ivy(),
      {
        mappings = {
          i = {
            ['<c-t>'] = require('trouble.sources.telescope').open,
            ['<c-p>'] = require('telescope.actions.layout').toggle_preview,
          },
          n = {
            ['<c-t>'] = require('trouble.sources.telescope').open,
            ['<c-p>'] = require('telescope.actions.layout').toggle_preview,
          },
        },
      }
    ),
    extensions = {
      recent_files = {
        stat_files = true,
        only_cwd = true,
      },
      hierarchy = {
        disable_devicons = true,
      },
    },
  })
  require('telescope').load_extension('fzf')
  require('telescope').load_extension('recent_files')
  require('telescope').load_extension('dir')
  require('telescope').load_extension('live_grep_args')
  require('telescope').load_extension('telescope-tabs')
  require('telescope-tabs').setup({})
  require('telescope').load_extension('yank_history')
  require('telescope').load_extension('undo')
  require('telescope').load_extension('fidget')
  require('telescope').load_extension('aerial')
  require('telescope').load_extension('hierarchy')
  require('telescope').load_extension('textcase')
EOF

  nnoremap <leader>ff <cmd>lua require('telescope.builtin').find_files()<cr>
  nnoremap <leader>fdf <cmd>lua require('telescope').extensions.dir.find_files()<cr>
  nnoremap <leader>fe <cmd>lua require('telescope').extensions.recent_files.pick()<cr>
  nnoremap <leader>fg <cmd>lua require('telescope').extensions.live_grep_args.live_grep_args()<cr>
  vnoremap <leader>fg <cmd>lua require('telescope-live-grep-args.shortcuts').grep_visual_selection()<cr>
  nnoremap <leader>fdg <cmd>lua require('telescope').extensions.dir.live_grep()<cr>
  nnoremap <leader>fb <cmd>lua require('telescope.builtin').buffers()<cr>
  nnoremap <leader>ft <cmd>Telescope telescope-tabs list_tabs<cr>
  nnoremap <leader>fp <cmd>lua require('telescope.builtin').diagnostics()<cr>
  nnoremap <leader>fj <cmd>lua require('telescope.builtin').jumplist()<cr>
  nnoremap <leader>fl <cmd>lua require('telescope.builtin').loclist()<cr>
  nnoremap <leader>fq <cmd>lua require('telescope.builtin').quickfix()<cr>
  nnoremap <leader>fy <cmd>lua require('telescope').extensions.yank_history.yank_history()<cr>
  nnoremap <leader>fu <cmd>lua require('telescope').extensions.undo.undo()<cr>
  nnoremap <leader>fo <cmd>lua require("telescope").extensions.aerial.aerial()<cr>
  nnoremap <leader>fO <cmd>lua require('telescope.builtin').lsp_dynamic_workspace_symbols({ignore_symbols={'variable', 'field'}, fname_width = 60})<cr>
  nnoremap <leader>fn <cmd>lua require('telescope').extensions.fidget.fidget()<cr>
  nnoremap <leader>fc <cmd>lua require('telescope.builtin').commands()<cr>
  nnoremap <leader>f/ <cmd>Telescope<cr>
endfunction

if has('nvim')
  call InitTelescope()
endif

" " folke/trouble.nvim
function! InitTrouble() abort
  lua << EOF
  require('trouble').setup({
    focus = true,
    auto_preview = false,
    auto_jump = false,
    icons = {
      indent = {
        fold_open     = "  ",
        fold_closed   = "│ ",
      },
      folder_closed   = "",
      folder_open     = "",
      kinds = {
        Array         = "",
        Boolean       = "",
        Class         = "",
        Constant      = "",
        Constructor   = "",
        Enum          = "",
        EnumMember    = "",
        Event         = "",
        Field         = "",
        File          = "",
        Function      = "",
        Interface     = "",
        Key           = "",
        Method        = "",
        Module        = "",
        Namespace     = "",
        Null          = "",
        Number        = "",
        Object        = "",
        Operator      = "",
        Package       = "",
        Property      = "",
        String        = "",
        Struct        = "",
        TypeParameter = "",
        Variable      = "",
      },
    },
  })

  vim.api.nvim_create_autocmd("QuickFixCmdPost", {
    callback = function()
      vim.cmd([[Trouble qflist open]])
    end,
  })
EOF

  nnoremap <leader>td <cmd>Trouble lsp_definitions toggle<CR>
  nnoremap <leader>tD <cmd>Trouble lsp_implementations toggle<CR>
  nnoremap <leader>ti <cmd>Trouble lsp_implementations toggle<CR>
  nnoremap <leader>ty <cmd>Trouble lsp_type_definitions toggle<CR>
  nnoremap <leader>tr <cmd>Trouble lsp_references toggle<CR>
  nnoremap <leader>tp <cmd>Trouble diagnostics toggle filter.buf=0<CR>
  nnoremap <leader>tl <cmd>Trouble loclist toggle<CR>
  nnoremap <leader>tq <cmd>Trouble qflist toggle<CR>
  nnoremap <leader>t/ <cmd>Trouble<cr>
endfunction

if has('nvim')
  call InitTrouble()
endif

" " nvim-tree/nvim-tree.lua
function! InitLazyNvimTree() abort
  lua << EOF
  local api = require("nvim-tree.api")
  local openfile = require'nvim-tree.actions.node.open-file'
  local actions = require'telescope.actions'
  local action_state = require'telescope.actions.state'
  local M = {}

  local view_selection = function(prompt_bufnr, map)
    actions.select_default:replace(function()
      actions.close(prompt_bufnr)
      local selection = action_state.get_selected_entry()
      local filename = selection.filename
      if (filename == nil) then
        filename = selection[1]
      end
      openfile.fn('preview', filename)
    end)
    return true
  end

  function M.launch_live_grep(opts)
    return M.launch_telescope("live_grep", opts)
  end

  function M.launch_find_files(opts)
    return M.launch_telescope("find_files", opts)
  end

  function M.launch_telescope(func_name, opts)
    local telescope_status_ok, _ = pcall(require, "telescope")
    if not telescope_status_ok then
      return
    end
    local node = api.tree.get_node_under_cursor()
    local is_folder = node.fs_stat and node.fs_stat.type == 'directory' or false
    local basedir = is_folder and node.absolute_path or vim.fn.fnamemodify(node.absolute_path, ":h")
    if (node.name == '..' and TreeExplorer ~= nil) then
      basedir = TreeExplorer.cwd
    end
    opts = opts or {}
    opts.cwd = basedir
    opts.search_dirs = { basedir }
    opts.attach_mappings = view_selection
    return require("telescope.builtin")[func_name](opts)
  end

  require("nvim-tree").setup({
    renderer = {
      icons = {
        show = {
          file = false,
          folder = false,
          folder_arrow = false,
          git = false,
          modified = false,
          hidden = false,
          diagnostics = false,
          bookmarks = true,
        },
        glyphs = {
          bookmark = "M",
        },
      },
      indent_markers = {
        enable = true,
      },
    },
    view = {
      width = 40,
    },
    git = {
      enable = false,
    },
    sync_root_with_cwd = true,
    respect_buf_cwd = true,
    update_focused_file = {
      enable = true,
      update_root = true,
    },
    filters = {
      enable = true,
      git_ignored = true,
      dotfiles = false,
      custom = { "^.git$" },
    },
    actions = {
      open_file = {
        quit_on_open = true,
      },
    },
    on_attach = function (bufnr)
      local api = require('nvim-tree.api')

      local function opts(desc)
        return { desc = 'nvim-tree: ' .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
      end

      api.config.mappings.default_on_attach(bufnr)

      vim.keymap.set('n', '<c-f>', M.launch_find_files, opts('Launch Find Files'))
      vim.keymap.set('n', '<c-g>', M.launch_live_grep,  opts('Launch Live Grep'))
    end,
  })
EOF
endfunction

function! LazyNvimTreeToggle() abort
  if ! exists('g:inited_nvim_tree')
    call InitLazyNvimTree()
    let g:inited_nvim_tree = 1
  endif

  NvimTreeToggle
endfunction

function! InitNvimTree() abort
  nnoremap <leader>tt <cmd>call LazyNvimTreeToggle()<CR>
  nnoremap <leader>tf <cmd>call LazyNvimTreeToggle()<CR>
endfunction

if has('nvim')
  call InitNvimTree()
endif

" " stevearc/aerial.nvim
function! InitAerial() abort
  lua << EOF
  require('aerial').setup({
    layout = {
      default_direction = 'left',
    },
    close_on_select = true,
    autojump = true,
    show_guides = true,
  })
EOF

  nnoremap <leader>to <cmd>AerialToggle<cr>
endfunction

if has('nvim')
  call InitAerial()
endif

" " ahmedkhalf/project.nvim
function! InitProjectNvim() abort
  lua << EOF
  require('project_nvim').setup({
    scope_chdir = 'tab',
    silent_chdir = false,
    patterns = {
      ".git",
      "_darcs",
      ".hg",
      ".bzr",
      ".svn",
      --"Makefile",
      "package.json"
    },
  })
EOF
endfunction

if has('nvim')
  call InitProjectNvim()
endif

" " nvim-lualine/lualine.nvim or vim-airline/vim-airline
function! InitLualine() abort
  lua << EOF
  local function multicursors_is_active()
    local ok, hydra = pcall(require, 'hydra.statusline')
    return ok and hydra.is_active()
  end

  local function multicursors_get_name()
    local ok, hydra = pcall(require, 'hydra.statusline')
    if ok then
        return hydra.get_name()
    end
    return ''
  end

  local function diff_source()
    local gitsigns = vim.b.gitsigns_status_dict
    if gitsigns then
      return {
        added = gitsigns.added,
        modified = gitsigns.changed,
        removed = gitsigns.removed
      }
    end
  end

  local symbols = require('trouble').statusline({
    mode = "lsp_document_symbols",
    groups = {},
    title = false,
    filter = { range = true },
    format = "{symbol.name}",
  })

  require('lualine').setup({
    options = {
      icons_enabled = false,
      component_separators = { left = '', right = '' },
      section_separators = { left = '', right = '' },
    },
    extensions = {'aerial', 'nvim-tree', 'fugitive', 'oil', 'trouble', 'quickfix'},
    sections = {
      lualine_a = { 'mode', { multicursors_get_name, cond = multicursors_is_active } },
      lualine_b = { 'b:gitsigns_head', {'diff', source = diff_source} },
      lualine_c = { {'filename', path = 1}, 'diagnostics' },
      lualine_x = { { symbols.get, cond = symbols.has, }, },
      lualine_y = { 'filetype' },
      lualine_z = { 'location' }
    },
  })
EOF
endfunction

function! InitAirline() abort
  if !exists('g:airline_symbols')
    let g:airline_symbols = {}
  endif
  let g:airline_symbols.branch = '⎇'
  let g:airline_symbols.paste = 'ρ'
  let g:airline_symbols.readonly = '∥'
  let g:airline_symbols.whitespace = 'Ξ'
  let g:airline_symbols.linenr = ''
  let g:airline_symbols.maxlinenr = ''
  let g:airline_symbols.colnr = ':'

  let g:airline_skip_empty_sections = 1
  autocmd User AirlineAfterInit :let g:airline_section_y = ''
  autocmd User AirlineAfterInit :let g:airline_section_z = airline#section#create(['linenr', 'colnr'])

  let g:airline#extensions#whitespace#enabled = 0
endfunction

if has('nvim')
  call InitLualine()
else
  call InitAirline()
endif

" " akinsho/bufferline.nvim or ap/vim-buftabline
function! InitBufferlineNvim() abort
  lua << EOF
  require('bufferline').setup({
    options = {
      style_preset = {
        require('bufferline').style_preset.no_italic,
        require('bufferline').style_preset.no_bold,
      },
      show_buffer_icons = false,
      show_buffer_close_icons = false,
      show_close_icon = false,
      show_tab_indicators = true,
      modified_icon = '',
      close_command = 'Bdelete %d',
      right_mouse_command = 'Bdelete %d',
    }
  })

  require('scope').setup({})
EOF

  nnoremap <C-P> <cmd>BufferLineCyclePrev<CR>
  nnoremap <C-N> <cmd>BufferLineCycleNext<CR>

  nnoremap <silent>[b <cmd>BufferLineCyclePrev<CR>
  nnoremap <silent>]b <cmd>BufferLineCycleNext<CR>

  nnoremap <C-1> <cmd>BufferLineGoToBuffer 1<CR>
  nnoremap <C-2> <cmd>BufferLineGoToBuffer 2<CR>
  nnoremap <C-3> <cmd>BufferLineGoToBuffer 3<CR>
  nnoremap <C-4> <cmd>BufferLineGoToBuffer 4<CR>
  nnoremap <C-5> <cmd>BufferLineGoToBuffer 5<CR>
  nnoremap <C-6> <cmd>BufferLineGoToBuffer 6<CR>
  nnoremap <C-7> <cmd>BufferLineGoToBuffer 7<CR>
  nnoremap <C-8> <cmd>BufferLineGoToBuffer 8<CR>
  nnoremap <C-9> <cmd>BufferLineGoToBuffer 9<CR>
  nnoremap <C-0> <cmd>BufferLineGoToBuffer -1<CR>
  nnoremap <leader>1 <cmd>BufferLineGoToBuffer 1<CR>
  nnoremap <leader>2 <cmd>BufferLineGoToBuffer 2<CR>
  nnoremap <leader>3 <cmd>BufferLineGoToBuffer 3<CR>
  nnoremap <leader>4 <cmd>BufferLineGoToBuffer 4<CR>
  nnoremap <leader>5 <cmd>BufferLineGoToBuffer 5<CR>
  nnoremap <leader>6 <cmd>BufferLineGoToBuffer 6<CR>
  nnoremap <leader>7 <cmd>BufferLineGoToBuffer 7<CR>
  nnoremap <leader>8 <cmd>BufferLineGoToBuffer 8<CR>
  nnoremap <leader>9 <cmd>BufferLineGoToBuffer 9<CR>
  nnoremap <leader>0 <cmd>BufferLineGoToBuffer -1<CR>

  cnoreabbrev bql BufferLineCloseLeft
  cnoreabbrev bqr BufferLineCloseRight

  lua << EOF
  vim.api.nvim_create_user_command('BufferLineCloseIdx',
    function (opts)
      local num = tonumber(opts.fargs[1])
      require('bufferline').exec(num, function(buf, visible_buffers)
        vim.cmd('Bdelete ' .. buf.id)
      end)
    end,
    {
      nargs = 1,
    }
  )
EOF
  cnoreabbrev bq1 BufferLineCloseIdx 1
  cnoreabbrev bq2 BufferLineCloseIdx 2
  cnoreabbrev bq3 BufferLineCloseIdx 3
  cnoreabbrev bq4 BufferLineCloseIdx 4
  cnoreabbrev bq5 BufferLineCloseIdx 5
  cnoreabbrev bq6 BufferLineCloseIdx 6
  cnoreabbrev bq7 BufferLineCloseIdx 7
  cnoreabbrev bq8 BufferLineCloseIdx 8
  cnoreabbrev bq9 BufferLineCloseIdx 9

  nnoremap <C--> <cmd>BufferLineMovePrev<CR>
  nnoremap <C-=> <cmd>BufferLineMoveNext<CR>
endfunction

function! InitBuftablineVim() abort
  nnoremap <C-P> :bp<CR>
  nnoremap <C-N> :bn<CR>

  nnoremap <C-1> <Plug>BufTabLine.Go(1)
  nnoremap <C-2> <Plug>BufTabLine.Go(2)
  nnoremap <C-3> <Plug>BufTabLine.Go(3)
  nnoremap <C-4> <Plug>BufTabLine.Go(4)
  nnoremap <C-5> <Plug>BufTabLine.Go(5)
  nnoremap <C-6> <Plug>BufTabLine.Go(6)
  nnoremap <C-7> <Plug>BufTabLine.Go(7)
  nnoremap <C-8> <Plug>BufTabLine.Go(8)
  nnoremap <C-9> <Plug>BufTabLine.Go(9)
  nnoremap <C-0> <Plug>BufTabLine.Go(-1)
  nnoremap <leader>1 <Plug>BufTabLine.Go(1)
  nnoremap <leader>2 <Plug>BufTabLine.Go(2)
  nnoremap <leader>3 <Plug>BufTabLine.Go(3)
  nnoremap <leader>4 <Plug>BufTabLine.Go(4)
  nnoremap <leader>5 <Plug>BufTabLine.Go(5)
  nnoremap <leader>6 <Plug>BufTabLine.Go(6)
  nnoremap <leader>7 <Plug>BufTabLine.Go(7)
  nnoremap <leader>8 <Plug>BufTabLine.Go(8)
  nnoremap <leader>9 <Plug>BufTabLine.Go(9)
  nnoremap <leader>0 <Plug>BufTabLine.Go(-1)
endfunction

if has('nvim')
  call InitBufferlineNvim()
else
  call InitBuftablineVim()
endif

" " yorickpeterse/nvim-pqf
function! InitPqf() abort
  lua require('pqf').setup()
endfunction

if has('nvim')
  call InitPqf()
endif

" " j-hui/fidget.nvim
function! InitFidget() abort
  lua << EOF
  require('fidget').setup({})

  vim.notify = require('fidget').notify
EOF
endfunction

if has('nvim')
  call InitFidget()
endif

" " lewis6991/gitsigns.nvim
function! InitGitSigns() abort
  lua << EOF
  require('gitsigns').setup({
    on_attach = function(bufnr)
      local gitsigns = require('gitsigns')
      local function map(mode, l, r, opts)
        opts = opts or {}
        opts.buffer = bufnr
        vim.keymap.set(mode, l, r, opts)
      end
      map('n', ']h', function()
        if vim.wo.diff then
          vim.cmd.normal({']h', bang = true})
        else
          gitsigns.nav_hunk('next')
        end
      end)
      map('n', '[h', function()
        if vim.wo.diff then
          vim.cmd.normal({'[h', bang = true})
        else
          gitsigns.nav_hunk('prev')
        end
      end)
    end
  })
EOF
endfunction

if has('nvim')
  call InitGitSigns()
endif

" " kinsho/git-conflict.nvim
function! InitGitConflict() abort
  lua require('git-conflict').setup()
endfunction

if has('nvim')
  call InitGitConflict()
endif

" " Maan2003/lsp_lines.nvim
function! InitLspLines() abort
  lua << EOF
  require('lsp_lines').setup()
  vim.diagnostic.config({
    virtual_text = false,
    virtual_lines = {
      only_current_line = true,
    },
  })
EOF
endfunction

if has('nvim')
  call InitLspLines()
endif

" " RRethy/vim-illuminate
function! InitIlluminate() abort
  lua << EOF
  require('illuminate').configure({
    disable_keymaps = true,
    filetypes_denylist = {
      'NvimTree',
      'trouble',
      'oil',
    },
  })
EOF
endfunction

if has('nvim')
  call InitIlluminate()
endif

" " nvim-treesitter/nvim-treesitter
function! InitTreesitter() abort
  lua << EOF
  require('nvim-treesitter.configs').setup({
    ensure_installed = {
      'c',
      'go',
      'python',
      'perl',
      'lua',
      'javascript',
      'typescript',
      'tsx',
      'html',
      'vim',
      'jinja',
      'json',
      'yaml',
      'bash',
      'sql',
      'markdown',
      'diff',
      'git_rebase',
    },
    sync_install = false,
    auto_install = true,
    highlight = {
      enable = true,
    },
    indent = {
      enable = false,
    },
    textobjects = {
      select = {
        enable = true,
        lookahead = true,
        keymaps = {
          ["aa"] = { query = "@parameter.outer", desc = "Select outer part of a parameter/argument" },
          ["ia"] = { query = "@parameter.inner", desc = "Select inner part of a parameter/argument" },
          ["ai"] = { query = "@conditional.outer", desc = "Select outer part of a conditional" },
          ["ii"] = { query = "@conditional.inner", desc = "Select inner part of a conditional" },
          ["al"] = { query = "@loop.outer", desc = "Select outer part of a loop" },
          ["il"] = { query = "@loop.inner", desc = "Select inner part of a loop" },
          ["af"] = { query = "@call.outer", desc = "Select outer part of a function call" },
          ["if"] = { query = "@call.inner", desc = "Select inner part of a function call" },
          ["am"] = { query = "@function.outer", desc = "Select outer part of a method/function definition" },
          ["im"] = { query = "@function.inner", desc = "Select inner part of a method/function definition" },
          ["ac"] = { query = "@class.outer", desc = "Select outer part of a class" },
          ["ic"] = { query = "@class.inner", desc = "Select inner part of a class" },
        },
      },
      swap = {
        enable = true,
        swap_next = {
          ["cm"] = "@parameter.inner",
        },
      },
      move = {
        enable = true,
        set_jumps = true,
        goto_next_start = {
          ["]f"] = { query = "@call.outer", desc = "Next function call start" },
          ["]m"] = { query = "@function.outer", desc = "Next method/function def start" },
          ["]c"] = { query = "@class.outer", desc = "Next class start" },
          ["]i"] = { query = "@conditional.outer", desc = "Next conditional start" },
          ["]l"] = { query = "@loop.outer", desc = "Next loop start" },
        },
        goto_next_end = {
          ["]F"] = { query = "@call.outer", desc = "Next function call end" },
          ["]M"] = { query = "@function.outer", desc = "Next method/function def end" },
          ["]C"] = { query = "@class.outer", desc = "Next class end" },
          ["]I"] = { query = "@conditional.outer", desc = "Next conditional end" },
          ["]L"] = { query = "@loop.outer", desc = "Next loop end" },
        },
        goto_previous_start = {
          ["[f"] = { query = "@call.outer", desc = "Prev function call start" },
          ["[m"] = { query = "@function.outer", desc = "Prev method/function def start" },
          ["[c"] = { query = "@class.outer", desc = "Prev class start" },
          ["[i"] = { query = "@conditional.outer", desc = "Prev conditional start" },
          ["[l"] = { query = "@loop.outer", desc = "Prev loop start" },
        },
        goto_previous_end = {
          ["[F"] = { query = "@call.outer", desc = "Prev function call end" },
          ["[M"] = { query = "@function.outer", desc = "Prev method/function def end" },
          ["[C"] = { query = "@class.outer", desc = "Prev class end" },
          ["[I"] = { query = "@conditional.outer", desc = "Prev conditional end" },
          ["[L"] = { query = "@loop.outer", desc = "Prev loop end" },
        },
      },
    },
  })
EOF
endfunction

if has('nvim')
  call InitTreesitter()
endif

" " folke/which-key.nvim or liuchengxu/vim-which-key
function! InitWhichKeyNvim() abort
  lua << EOF
  require('which-key').setup({
    delay = function(ctx)
      return ctx.plugin and 0 or 500
    end,
    icons = {
      mappings = false,
      keys = {
        Up = "<Up>",
        Down = "<Down>",
        Left = "<Left>",
        Right = "<Right>",
        C = "<C>",
        M = "<M>",
        D = "<D>",
        S = "<S>",
        CR = "<CR>",
        Esc = "<Esc>",
        ScrollWheelDown = "<ScrollWheelDown>",
        ScrollWheelUp = "<ScrollWheelUp>",
        NL = "<NL>",
        BS = "<BS>",
        Space = "<Space>",
        Tab = "<Tab>",
        F1 = "<F1>",
        F2 = "<F2>",
        F3 = "<F3>",
        F4 = "<F4>",
        F5 = "<F5>",
        F6 = "<F6>",
        F7 = "<F7>",
        F8 = "<F8>",
        F9 = "<F9>",
        F10 = "<F10>",
        F11 = "<F11>",
        F12 = "<F12>",
      },
    },
  })
EOF

  nnoremap <leader>fk <cmd>WhichKey<cr>
endfunction

function! InitWhichKeyVim() abort
  nnoremap <leader>fk :WhichKey
endfunction

if has('nvim')
  call InitWhichKeyNvim()
else
  call InitWhichKeyVim()
endif

" " sindrets/diffview.nvim
function! InitLazyDiffview() abort
  lua << EOF
  require('diffview').setup({
    use_icons = false,
    icons = {
      folder_closed = "",
      folder_open = "",
    },
    signs = {
      fold_closed = "",
      fold_open = "",
    },
  })
EOF
endfunction

if has('nvim')
  autocmd User diffview.nvim call InitLazyDiffview()
endif

" " nvim-pack/nvim-spectre
function! InitLazySpectre() abort
  lua << EOF
  require('spectre').setup({
    use_trouble_qf = true,
    is_insert_mode = true,
    is_block_ui_break = true,
  })
EOF
endfunction

function! InitSpectre() abort
  nnoremap <leader>s <cmd>Spectre<cr>
endfunction

if has('nvim')
  autocmd User nvim-spectre call InitLazySpectre()
  call InitSpectre()
endif

" " stevearc/oil.nvim
function! InitOil() abort
  lua require('oil').setup()
endfunction

if has('nvim')
  call InitOil()
endif


" own commands
" " yank file line reference
command YankReference redir @+ | echo join([expand('%'), line('.')], ':') | redir END

" " sublime text & sublime merge integration
if has('nvim')
  lua << EOF
  vim.api.nvim_create_user_command('Subl',
    function (opts)
      if opts.fargs[1] == 'dir' then
        vim.cmd('!subl ' .. vim.fn.getcwd())
      else
        vim.cmd('!subl %')
      end
    end,
    {
      desc = 'Open in Sublime Text',
      nargs = '?',
      complete = function ()
        return {'dir'}
      end,
    }
  )

  vim.api.nvim_create_user_command('Smerge',
    function (opts)
      if opts.fargs[1] == 'blame' then
        vim.cmd('!smerge blame %')
      elseif opts.fargs[1] == 'log' then
        vim.cmd('!smerge log %')
      else
        vim.cmd('!smerge ' .. vim.fn.getcwd())
      end
    end,
    {
      desc = 'Open in Sublime Merge',
      nargs = '?',
      complete = function ()
        return {'dir', 'blame', 'log'}
      end,
    }
  )
EOF
endif


" vim mappings
nnoremap j gj
nnoremap k gk

nnoremap <silent> } :<C-u>execute "keepjumps norm! " . v:count1 . "}"<CR> " https://superuser.com/a/836924/2151180
nnoremap <silent> { :<C-u>execute "keepjumps norm! " . v:count1 . "{"<CR>

nnoremap <expr> gV '`[' . getregtype()[0] . '`]'

cnoreabbrev E e
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev Wqa wqa
cnoreabbrev w!! w !sudo tee % >/dev/null

cnoreabbrev tabq tabclose
cnoreabbrev tnew tabnew
cnoreabbrev tq tabclose
nnoremap <C-S-P> <cmd>tabprev<CR>
nnoremap <C-S-N> <cmd>tabnext<CR>

nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <C-Up> <cmd>resize +2<cr>
nnoremap <C-Down> <cmd>resize -2<cr>
nnoremap <C-Right> <cmd>vertical resize +2<cr>
nnoremap <C-Left> <cmd>vertical resize -2<cr>

nnoremap <leader>y "+y
nnoremap <leader>Y "+Y
nnoremap <leader>p "+p
nnoremap <leader>P "+P
vnoremap <leader>y "+y
vnoremap <leader>Y "+Y
vnoremap <leader>p "+p
vnoremap <leader>P "+P

nnoremap <C-S> :w<CR>
inoremap <C-S> <Esc>:w<CR>l
vnoremap <C-S> <Esc>:w<CR>


" vim settings
" " appearance
set number
set relativenumber
set cursorline
set colorcolumn=80,120
set scrolloff=5
set sidescroll=1

augroup BgHighlight
  autocmd!
  autocmd InsertEnter * set cursorline | set colorcolumn=80,120 | if (&ft ==? "TelescopePrompt") | set nocursorline | endif | if (&ft ==? "TelescopePrompt" || &ft ==? "trouble" || &ft ==? "fugitive" || &ft ==? "DiffviewFileHistory" || &ft ==? "spectre_panel" || &ft ==? "oil") | set colorcolumn=0 | endif
  autocmd WinEnter *    set cursorline | set colorcolumn=80,120 | if (&ft ==? "TelescopePrompt") | set nocursorline | endif | if (&ft ==? "TelescopePrompt" || &ft ==? "trouble" || &ft ==? "fugitive" || &ft ==? "DiffviewFileHistory" || &ft ==? "spectre_panel" || &ft ==? "oil") | set colorcolumn=0 | endif
  autocmd WinLeave *    set nocursorline | set colorcolumn=0 | if (&ft ==? "NvimTree") | set cursorline | endif
augroup END

set nowrap

if has('nvim')
  set cmdheight=0
endif
set noshowmode

if has('nvim')
  set mouse=a
else
  set mouse=i
endif

set shortmess+=aITF
if has('patch-7.4.314')
  set shortmess+=c
endif
set title
set confirm
if exists('+signcolumn')
  set signcolumn=yes
endif
set breakindent
set breakindentopt=sbr
set showbreak=↪
let g:vimsyn_embed = 'l'

" " editing
set shiftwidth=4
set tabstop=4
set softtabstop=4
set expandtab

set autoindent
set copyindent
set smartindent

set nrformats+=unsigned

set nospell

set completeopt=menu,menuone,preview
set foldlevelstart=99
set foldmethod=syntax
if has('nvim')
  lua << EOF
  vim.api.nvim_create_autocmd({ "FileType" }, {
    callback = function()
      if require("nvim-treesitter.parsers").has_parser() then
        vim.opt.foldmethod = "expr"
        vim.opt.foldexpr = "nvim_treesitter#foldexpr()"
      else
        vim.opt.foldmethod = "syntax"
      end
    end,
  })
EOF
endif
set whichwrap+=b,s,h,l,<,>
set updatetime=300

set splitright
set splitbelow

set hidden
set autoread
set autowriteall
set undofile
set nobackup
set nowritebackup
set noswapfile

" " navigation
set ignorecase
set smartcase
set hlsearch

" " encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,cp1251,latin1
set fileformats=unix,dos,mac

" " other
set backupdir=~/.vim/backup
set directory=~/.vim/tmp
set undodir=~/.vim/undo
set viewdir=~/.vim/view
if &shell =~# 'fish$'
  set shell=/bin/bash
endif


" neovide
if exists('g:neovide')
  language en_US
  language messages en_US
  language ctype en_US
  language time en_US
  set langmenu=en_US
  let $LANG = 'en_US'

  set guifont=Jetbrains\ Mono:h14:#e-subpixelantialias:#h-none
  set linespace=2

  lua vim.g.neovide_hide_mouse_when_typing = true
  lua vim.g.neovide_position_animation_length = 0
  lua vim.g.neovide_cursor_animation_length = 0.00
  lua vim.g.neovide_cursor_trail_size = 0
  lua vim.g.neovide_cursor_animate_in_insert_mode = false
  lua vim.g.neovide_cursor_animate_command_line = false
  lua vim.g.neovide_scroll_animation_far_lines = 0
  lua vim.g.neovide_scroll_animation_length = 0.00
endif
if has('nvim')
  lua vim.keymap.set('n', '<D-s>', ':w<CR>')
  lua vim.keymap.set('v', '<D-c>', '"+y')
  lua vim.keymap.set('n', '<D-v>', '"+P')
  lua vim.keymap.set('v', '<D-v>', '"+P')
  lua vim.keymap.set('c', '<D-v>', '<C-R>+')
  lua vim.keymap.set('i', '<D-v>', '<ESC>l"+Pli')
  lua vim.api.nvim_set_keymap('', '<D-v>', '+p<CR>', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('!', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('t', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('v', '<D-v>', '<C-R>+', { noremap = true, silent = true })
endif
