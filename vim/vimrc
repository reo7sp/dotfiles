set nocompatible
let g:loaded_netrwPlugin = 1
let g:loaded_netrw = 1

let mapleader = ","


" plugins
call plug#begin('~/.vim/bundle')

" " generic
Plug 'Shougo/vimproc.vim', {'do': 'make'}
if has('nvim')
  Plug 'nvim-lua/plenary.nvim'
  Plug 'kkharji/sqlite.lua'
endif
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-repeat'

" " editing
if has('nvim')
  Plug 'neovim/nvim-lspconfig'
  Plug 'williamboman/mason.nvim'
  Plug 'williamboman/mason-lspconfig.nvim'
  Plug 'hrsh7th/nvim-cmp'
  Plug 'hrsh7th/cmp-nvim-lsp'
  Plug 'hrsh7th/cmp-buffer'
  Plug 'hrsh7th/cmp-path'
  Plug 'L3MON4D3/LuaSnip'
  Plug 'saadparwaiz1/cmp_luasnip'
  Plug 'rafamadriz/friendly-snippets'
else
  Plug 'vim-scripts/AutoComplPop'
endif
Plug 'Raimondi/delimitMate'
Plug 'wellle/targets.vim'
Plug 'romainl/vim-cool'
Plug 'ConradIrwin/vim-bracketed-paste'
if has('nvim')
  Plug 'okuuva/auto-save.nvim'
endif
Plug 'pbrisbin/vim-mkdir'
Plug 'tpope/vim-sleuth'
Plug 'ntpeters/vim-better-whitespace'
if has('nvim')
  Plug 'gbprod/yanky.nvim'
  Plug 'debugloop/telescope-undo.nvim'
else
  Plug 'maxbrunsfeld/vim-yankstack'
endif
if has('nvim')
  Plug 'numToStr/Comment.nvim'
else
  Plug 'scrooloose/nerdcommenter'
endif
if has('nvim')
  Plug 'echasnovski/mini.align'
  Plug 'echasnovski/mini.splitjoin'
endif

" " navigation
Plug 'justinmk/vim-sneak'
Plug 'tpope/vim-unimpaired'
Plug 'moll/vim-bbye'
Plug 'vim-scripts/BufOnly.vim'
if has('nvim')
  Plug 'nvim-telescope/telescope.nvim', {'tag': '0.1.8'}
  Plug 'smartpde/telescope-recent-files'
  Plug 'nvim-telescope/telescope-live-grep-args.nvim'
  Plug 'princejoogie/dir-telescope.nvim'
endif
if has('nvim')
  Plug 'folke/trouble.nvim'
endif
if has('nvim')
  Plug 'nvim-tree/nvim-tree.lua'
endif

" " appearance
Plug 'sainnhe/sonokai'
if has('nvim')
  Plug 'nvim-lualine/lualine.nvim'
else
  Plug 'vim-airline/vim-airline'
endif
Plug 'ap/vim-buftabline'
if has('nvim')
  Plug 'lewis6991/gitsigns.nvim'
  Plug 'sindrets/diffview.nvim'
else
  Plug 'airblade/vim-gitgutter'
endif
if has('nvim')
  Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
  Plug 'nvim-treesitter/nvim-treesitter-textobjects'
endif
if has('nvim')
  Plug 'dgagn/diagflow.nvim'
  Plug 'j-hui/fidget.nvim'
endif
Plug 'ekalinin/Dockerfile.vim'
Plug 'vim-scripts/nginx.vim'
Plug 'johejo/gomod.vim'

" " commands
Plug 'liuchengxu/vim-which-key'
if has('nvim')
  Plug 'AckslD/nvim-whichkey-setup.lua'
endif
Plug 'tpope/vim-fugitive'
if has('nvim')
  Plug 'nvim-pack/nvim-spectre'
endif

call plug#end()


" plugin settings
" " hrsh7th/nvim-cmp
function! LspAttached() abort
  nnoremap <buffer> K <cmd>lua vim.lsp.buf.hover()<cr>
  nnoremap <buffer> gd <cmd>lua require('telescope.builtin').lsp_definitions()<cr>
  nnoremap <buffer> gD <cmd>lua require('telescope.builtin').lsp_implementations()<cr>
  nnoremap <buffer> gi <cmd>lua require('telescope.builtin').lsp_implementations()<cr>
  nnoremap <buffer> gt <cmd>lua require('telescope.builtin').lsp_type_definitions()<cr>
  nnoremap <buffer> gr <cmd>lua require('telescope.builtin').lsp_references()<cr>
  nnoremap <buffer> gs <cmd>lua vim.lsp.buf.signature_help()<cr>
  nnoremap <buffer> <leader>lr <cmd>lua vim.lsp.buf.rename()<cr>
  nnoremap <buffer> <leader>lf <cmd>lua vim.lsp.buf.format({async = true})<cr>
  xnoremap <buffer> <leader>lf <cmd>lua vim.lsp.buf.format({async = true})<cr>
  nnoremap <buffer> <leader>lc <cmd>lua vim.lsp.buf.code_action()<cr>
endfunction

if has('nvim')
  autocmd LspAttach * call LspAttached()

  lua << EOF
  local lspconfig_defaults = require('lspconfig').util.default_config
  lspconfig_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lspconfig_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )
EOF
  lua << EOF
  require('mason').setup({})
EOF
  lua << EOF
  require('mason-lspconfig').setup({
    ensure_installed = { 'cmake', 'bashls', 'cssls', 'dockerls', 'gopls', 'html', 'ts_ls', 'jsonls', 'lua_ls', 'nginx_language_server', 'vacuum', 'perlnavigator', 'puppet', 'pyright', 'yamlls' },
    handlers = {
      function(server_name)
        require('lspconfig')[server_name].setup({})
      end,
    }
  })
EOF
  lua << EOF
  require('luasnip.loaders.from_vscode').lazy_load()
EOF
  lua << EOF
  local cmp = require('cmp')
  cmp.setup({
    sources = {
      {name = 'path'},
      {name = 'nvim_lsp'},
      {name = 'luasnip', keyword_length = 2},
      {name = 'buffer', keyword_length = 3},
    },
    preselect = 'none',
    completion = {
        completeopt = 'menu,menuone,noinsert,noselect'
    },
    snippet = {
      expand = function(args)
        require('luasnip').lsp_expand(args.body)
      end,
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ["<C-e>"] = cmp.mapping.close(),
      ["<CR>"] = cmp.mapping(function(fallback)
        if cmp.visible() then
          if luasnip.expandable() then
            luasnip.expand()
          else
            cmp.confirm({ select = true })
          end
        else
          fallback()
        end
      end),
      ['<Tab>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          local entry = cmp.get_selected_entry()
          if not entry then
            cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
          end
          cmp.confirm()
        elseif require('luasnip').expand_or_jumpable() then
          require('luasnip').expand_or_jump()
        else
          fallback()
        end
      end, { "i", "s" }),
      ['<S-Tab>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          cmp.select_prev_item()
        elseif require('luasnip').jumpable(-1) then
          require('luasnip').jump(-1)
        else
          fallback()
        end
      end, { 'i', 's' }),
    }),
  })
EOF

  augroup NvimCmp
  au!
  au FileType TelescopePrompt lua require('cmp').setup.buffer({ enabled = false })
  augroup END
endif

" " okuuva/auto-save.nvim
if has('nvim')
  lua require('auto-save').setup({})
endif

" " gbprod/yanky.nvim or maxbrunsfeld/vim-yankstack
if has('nvim')
  lua require('yanky').setup({})

  lua vim.keymap.set({"n","x"}, "p", "<Plug>(YankyPutAfter)")
  lua vim.keymap.set({"n","x"}, "P", "<Plug>(YankyPutBefore)")
  lua vim.keymap.set({"n","x"}, "gp", "<Plug>(YankyGPutAfter)")
  lua vim.keymap.set({"n","x"}, "gP", "<Plug>(YankyGPutBefore)")
  lua vim.keymap.set("n", "[y", "<Plug>(YankyPreviousEntry)")
  lua vim.keymap.set("n", "]y", "<Plug>(YankyNextEntry)")
else
  let g:yankstack_map_keys = 0
  nnoremap ]y <Plug>yankstack_substitute_older_paste
  nnoremap [y <Plug>yankstack_substitute_newer_paste
endif

" " numToStr/Comment.nvim or scrooloose/nerdcommenter
if has('nvim')
  lua require('Comment').setup()

  nnoremap <C-/> <Plug>(comment_toggle_linewise_current)
  nnoremap <C-_> <Plug>(comment_toggle_linewise_current)
  xnoremap <C-/> <Plug>(comment_toggle_linewise_visual)
  xnoremap <C-_> <Plug>(comment_toggle_linewise_visual)
else
  nnoremap <C-/> <Plug>NERDCommenterToggle
  nnoremap <C-_> <Plug>NERDCommenterToggle
  vnoremap <C-/> <Plug>NERDCommenterToggle<CR>gv
  vnoremap <C-_> <Plug>NERDCommenterToggle<CR>gv
end

" " echasnovski/mini.align
if has('nvim')
  lua require('mini.align').setup()
endif

" " echasnovski/mini.splitjoin
if has('nvim')
  lua require('mini.splitjoin').setup()
endif

" " justinmk/vim-sneak
autocmd VimEnter * noremap s <Plug>Sneak_s

let g:sneak#use_ic_scs = 1

" " moll/vim-bbye
cnoreabbrev bq Bdelete

" " vim-scripts/BufOnly.vim
cnoreabbrev bqo BufOnly
cnoreabbrev bo BufOnly

" " nvim-telescope/telescope.nvim
if has('nvim')
  lua require('telescope').setup({ defaults = require('telescope.themes').get_ivy() })
  lua require('telescope').load_extension('recent_files')
  lua require('telescope').load_extension('dir')
  lua require('telescope').load_extension('live_grep_args')
  lua require('telescope').load_extension('yank_history')
  lua require('telescope').load_extension('undo')
  lua require('telescope').load_extension('fidget')

  lua << EOF
  require('telescope').setup({
    defaults = {
      mappings = {
        i = { ["<c-t>"] = require("trouble.sources.telescope").open },
        n = { ["<c-t>"] = require("trouble.sources.telescope").open },
      },
    },
  })
EOF

  nnoremap <leader>ff <cmd>lua require('telescope.builtin').find_files()<cr>
  nnoremap <leader>fdf <cmd>lua require('telescope').extensions.dir.find_files()<cr>
  nnoremap <leader>fe <cmd>lua require('telescope').extensions.recent_files.pick({only_cwd = true})<cr>
  nnoremap <leader>fg <cmd>lua require('telescope').extensions.live_grep_args.live_grep_args()<cr>
  nnoremap <leader>fdg <cmd>lua require('telescope').extensions.dir.live_grep()<cr>
  nnoremap <leader>fb <cmd>lua require('telescope.builtin').buffers()<cr>
  nnoremap <leader>fj <cmd>lua require('telescope.builtin').jumplist()<cr>
  nnoremap <leader>fp <cmd>lua require('telescope.builtin').diagnostics()<cr>
  nnoremap <leader>fy <cmd>lua require('telescope').extensions.yank_history.yank_history()<cr>
  nnoremap <leader>fu <cmd>lua require('telescope').extensions.undo.undo()<cr>
  nnoremap <leader>fs <cmd>lua require('telescope.builtin').lsp_document_symbols()<cr>
  nnoremap <leader>fa <cmd>lua require('telescope.builtin').lsp_dynamic_workspace_symbols()<cr>
  nnoremap <leader>fv <cmd>lua require('telescope.builtin').treesitter()<cr>
  nnoremap <leader>fc <cmd>lua require('telescope.builtin').commands()<cr>
endif

" " folke/trouble.nvim
if has('nvim')
  lua << EOF
  require('trouble').setup({
    auto_preview = false,
  })
EOF
endif

" " nvim-tree/nvim-tree.lua
if has('nvim')
  nnoremap <leader>t :NvimTreeToggle<CR><C-W><C-W>

  lua << EOF
  require("nvim-tree").setup({
    renderer = {
      icons = {
        show = {
          file = false,
          folder = false,
          folder_arrow = false,
          git = false,
          modified = false,
          hidden = false,
          diagnostics = false,
          bookmarks = false,
        }
      }
    },
    update_focused_file = {
      enable = true,
    },
    filters = {
      custom = { "^.git$" },
    }
  })
EOF
endif

" " nvim-lualine/lualine.nvim or vim-airline/vim-airline
if has('nvim')
  lua << EOF
  local symbols = require('trouble').statusline({
    mode = "lsp_document_symbols",
    groups = {},
    title = false,
    filter = { range = true },
    format = "{symbol.name:Normal}",
    hl_group = "lualine_c_normal",
  })

  require('lualine').setup({
    options = {
      icons_enabled = false,
      component_separators = { left = '', right = '' },
      section_separators = { left = '', right = '' },
    },
    sections = {
      lualine_a = {'mode'},
      lualine_b = {'branch', 'diff'},
      lualine_c = { {'filename', path = 1}, 'diagnostics'},
      lualine_x = { { symbols.get, cond = symbols.has, }, },
      lualine_y = {'filetype'},
      lualine_z = {'progress', 'location'}
    },
  })
EOF
else
  if !exists('g:airline_symbols')
    let g:airline_symbols = {}
  endif
  let g:airline_symbols.branch = '⎇'
  let g:airline_symbols.paste = 'ρ'
  let g:airline_symbols.readonly = '∥'
  let g:airline_symbols.whitespace = 'Ξ'
  let g:airline_symbols.linenr = ''
  let g:airline_symbols.maxlinenr = ''
  let g:airline_symbols.colnr = ':'

  let g:airline_skip_empty_sections = 1
  autocmd User AirlineAfterInit :let g:airline_section_y = ''
  autocmd User AirlineAfterInit :let g:airline_section_z = airline#section#create(['%p%% ', 'linenr', 'colnr'])

  let g:airline#extensions#whitespace#enabled = 0
endif

" " lewis6991/gitsigns.nvim
if has('nvim')
  lua << EOF
  require('gitsigns').setup({
    on_attach = function(bufnr)
      local gitsigns = require('gitsigns')
      local function map(mode, l, r, opts)
        opts = opts or {}
        opts.buffer = bufnr
        vim.keymap.set(mode, l, r, opts)
      end
      map('n', ']h', function()
        if vim.wo.diff then
          vim.cmd.normal({']h', bang = true})
        else
          gitsigns.nav_hunk('next')
        end
      end)
      map('n', '[h', function()
        if vim.wo.diff then
          vim.cmd.normal({'[h', bang = true})
        else
          gitsigns.nav_hunk('prev')
        end
      end)
    end
  })
EOF
endif

" " nvim-treesitter/nvim-treesitter
if has('nvim')
  lua << EOF
  require("nvim-treesitter.configs").setup({
    ensure_installed = { "c", "go", "python", "lua", "javascript", "typescript", "tsx", "html", "vim", "json", "yaml", "bash", "markdown", "diff", "git_rebase" },
    sync_install = false,
    auto_install = true,
    highlight = {
      enable = true,
    },
    indent = {
      enable = false,
    },
    textobjects = {
      select = {
        enable = true,
        lookahead = true,
        keymaps = {
          ["a="] = { query = "@assignment.outer", desc = "Select outer part of an assignment" },
          ["i="] = { query = "@assignment.inner", desc = "Select inner part of an assignment" },
          ["l="] = { query = "@assignment.lhs", desc = "Select left hand side of an assignment" },
          ["r="] = { query = "@assignment.rhs", desc = "Select right hand side of an assignment" },
          ["aa"] = { query = "@parameter.outer", desc = "Select outer part of a parameter/argument" },
          ["ia"] = { query = "@parameter.inner", desc = "Select inner part of a parameter/argument" },
          ["ai"] = { query = "@conditional.outer", desc = "Select outer part of a conditional" },
          ["ii"] = { query = "@conditional.inner", desc = "Select inner part of a conditional" },
          ["al"] = { query = "@loop.outer", desc = "Select outer part of a loop" },
          ["il"] = { query = "@loop.inner", desc = "Select inner part of a loop" },
          ["af"] = { query = "@call.outer", desc = "Select outer part of a function call" },
          ["if"] = { query = "@call.inner", desc = "Select inner part of a function call" },
          ["am"] = { query = "@function.outer", desc = "Select outer part of a method/function definition" },
          ["im"] = { query = "@function.inner", desc = "Select inner part of a method/function definition" },
          ["ac"] = { query = "@class.outer", desc = "Select outer part of a class" },
          ["ic"] = { query = "@class.inner", desc = "Select inner part of a class" },
        },
      },
      swap = {
        enable = true,
        swap_next = {
          ["<leader>na"] = "@parameter.inner",
          ["<leader>nm"] = "@function.outer",
        },
        swap_previous = {
          ["<leader>pa"] = "@parameter.inner",
          ["<leader>pm"] = "@function.outer",
        },
      },
      move = {
        enable = true,
        set_jumps = true,
        goto_next_start = {
          ["]f"] = { query = "@call.outer", desc = "Next function call start" },
          ["]m"] = { query = "@function.outer", desc = "Next method/function def start" },
          ["]c"] = { query = "@class.outer", desc = "Next class start" },
          ["]i"] = { query = "@conditional.outer", desc = "Next conditional start" },
          ["]l"] = { query = "@loop.outer", desc = "Next loop start" },
          ["]s"] = { query = "@scope", query_group = "locals", desc = "Next scope" },
          ["]z"] = { query = "@fold", query_group = "folds", desc = "Next fold" },
        },
        goto_next_end = {
          ["]F"] = { query = "@call.outer", desc = "Next function call end" },
          ["]M"] = { query = "@function.outer", desc = "Next method/function def end" },
          ["]C"] = { query = "@class.outer", desc = "Next class end" },
          ["]I"] = { query = "@conditional.outer", desc = "Next conditional end" },
          ["]L"] = { query = "@loop.outer", desc = "Next loop end" },
        },
        goto_previous_start = {
          ["[f"] = { query = "@call.outer", desc = "Prev function call start" },
          ["[m"] = { query = "@function.outer", desc = "Prev method/function def start" },
          ["[c"] = { query = "@class.outer", desc = "Prev class start" },
          ["[i"] = { query = "@conditional.outer", desc = "Prev conditional start" },
          ["[l"] = { query = "@loop.outer", desc = "Prev loop start" },
        },
        goto_previous_end = {
          ["[F"] = { query = "@call.outer", desc = "Prev function call end" },
          ["[M"] = { query = "@function.outer", desc = "Prev method/function def end" },
          ["[C"] = { query = "@class.outer", desc = "Prev class end" },
          ["[I"] = { query = "@conditional.outer", desc = "Prev conditional end" },
          ["[L"] = { query = "@loop.outer", desc = "Prev loop end" },
        },
      },
    },
  })
EOF
endif

" " dgagn/diagflow.nvim
if has('nvim')
  lua << EOF
  require('diagflow').setup({
    placement = 'inline',
    inline_padding_left = 7,
    show_sign = true,
  })
EOF
endif

" " j-hui/fidget.nvim
if has('nvim')
  lua << EOF
  require('fidget').setup()
EOF
endif

" " liuchengxu/vim-which-key
nnoremap <leader>fk :WhichKey '

if has('nvim')
  lua << EOF
  require("whichkey_setup").config({
    hide_statusline = false,
    default_keymap_settings = {
      silent = true,
      noremap = true,
    },
    default_mode = 'n',
  })
EOF
endif

" " nvim-pack/nvim-spectre
if has('nvim')
  lua << EOF
  require('spectre').setup()

  vim.keymap.set('n', '<leader>s', '<cmd>lua require("spectre").toggle()<CR>', { desc = "Toggle Spectre" })
EOF
endif


" vim mappings
nnoremap j gj
nnoremap k gk

cnoreabbrev w!! w !sudo tee % >/dev/null
cnoreabbrev Wqa wqa
cnoreabbrev Qa qa
cnoreabbrev Q q

nnoremap <C-P> :bp<CR>
nnoremap <C-N> :bn<CR>
nnoremap <leader>1 <Plug>BufTabLine.Go(1)
nnoremap <leader>2 <Plug>BufTabLine.Go(2)
nnoremap <leader>3 <Plug>BufTabLine.Go(3)
nnoremap <leader>4 <Plug>BufTabLine.Go(4)
nnoremap <leader>5 <Plug>BufTabLine.Go(5)
nnoremap <leader>6 <Plug>BufTabLine.Go(6)
nnoremap <leader>7 <Plug>BufTabLine.Go(7)
nnoremap <leader>8 <Plug>BufTabLine.Go(8)
nnoremap <leader>9 <Plug>BufTabLine.Go(9)
nnoremap <leader>0 <Plug>BufTabLine.Go(-1)

nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <C-Up> <cmd>resize +2<cr>
nnoremap <C-Down> <cmd>resize -2<cr>
nnoremap <C-Right> <cmd>vertical resize +2<cr>
nnoremap <C-Left> <cmd>vertical resize -2<cr>

noremap <leader>y "+y
noremap <leader>Y "+Y
noremap <leader>p "+p
noremap <leader>P "+P

nnoremap <C-S> :w<CR>
inoremap <C-S> <Esc>:w<CR>l
vnoremap <C-S> <Esc>:w<CR>


" colors
syntax enable
set background=dark
set t_Co=256
if has('termguicolors')
  set termguicolors
endif

colorscheme sonokai
let g:airline_theme = 'sonokai'

let g:sonokai_enable_italic = 1

set colorcolumn=80,120

let g:vimsyn_embed = 'l'

" vim settings
" " editor appearance
set number
set relativenumber
set cul
set showmatch
set scrolloff=5
set sidescrolloff=5

set shiftwidth=4
set tabstop=4
set softtabstop=4
set expandtab

set mat=2

set shortmess+=aIT
if has("patch-7.4.314")
  set shortmess+=c
endif
set title
set confirm
set more
set ruler
set showmode
set showcmd

set foldenable
set foldmethod=syntax
set foldlevelstart=99

set nowrap
set linebreak
if exists('+breakindent')
  set breakindent
endif
set showbreak=+++\ 

" " gvim
set guioptions=gi

" " navigation
set incsearch
set hlsearch
set ignorecase
set smartcase

set magic

set wildmenu
set wildmode=longest:full,full
set wildignore+=*.o,*~,*.pyc,.git/*,*.meta,.sync/*

set nostartofline

" " editing
set autoindent
set copyindent
set smartindent
set smarttab

set nrformats-=octal

set viewoptions=folds,cursor,unix,slash

set backspace=eol,start,indent
set whichwrap+=<,>,h,l

set completeopt=longest,menuone,preview
set splitright
set splitbelow
if exists('+signcolumn')
  set signcolumn=yes
endif

set modeline
set modelines=5

set undofile
set autoread
set autowriteall
set nobackup
set nowritebackup

set nospell

set updatetime=300

" " encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,cp1251,latin1
set fileformats=unix,dos,mac

" " russian support
set keymap=russian-jcukenwin
set spelllang=ru_yo,en_us
set iskeyword=@,48-57,_,192-255
set langmap=ёйцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕHГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ;`qwertyuiop[]asdfghjkl\\;'zxcvbnm\\,.QWERTYUIOP{}ASDFGHJKL:\\"ZXCVBNM<>
set iminsert=0
set imsearch=0

" " other
set backupdir=~/.vim/backup
set directory=~/.vim/tmp
set undodir=~/.vim/undo
set viewdir=~/.vim/view
if &shell =~# 'fish$'
  set shell=/bin/bash
endif

set mouse=i
set hidden
set lazyredraw
set noerrorbells
set novisualbell
set history=700
set ttyfast
set timeout
set timeoutlen=1000
set ttimeout
set ttimeoutlen=10


" neovide
if exists('g:neovide')
  language en_US
  language messages en_US
  language ctype en_US
  language time en_US
  set langmenu=en_US
  let $LANG = 'en_US'

  set guifont=Jetbrains\ Mono:h14:#e-subpixelantialias:#h-none
  set linespace=2

  lua vim.g.neovide_hide_mouse_when_typing = true
  lua vim.g.neovide_position_animation_length = 0
  lua vim.g.neovide_cursor_animation_length = 0.00
  lua vim.g.neovide_cursor_trail_size = 0
  lua vim.g.neovide_cursor_animate_in_insert_mode = false
  lua vim.g.neovide_cursor_animate_command_line = false
  lua vim.g.neovide_scroll_animation_far_lines = 0
  lua vim.g.neovide_scroll_animation_length = 0.00

  lua vim.keymap.set('n', '<D-s>', ':w<CR>')
  lua vim.keymap.set('v', '<D-c>', '"+y')
  lua vim.keymap.set('n', '<D-v>', '"+P')
  lua vim.keymap.set('v', '<D-v>', '"+P')
  lua vim.keymap.set('c', '<D-v>', '<C-R>+')
  lua vim.keymap.set('i', '<D-v>', '<ESC>l"+Pli')
  lua vim.api.nvim_set_keymap('', '<D-v>', '+p<CR>', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('!', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('t', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  lua vim.api.nvim_set_keymap('v', '<D-v>', '<C-R>+', { noremap = true, silent = true })
endif
