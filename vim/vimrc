set nocompatible
let g:loaded_netrwPlugin = 1
let g:loaded_netrw = 1
let g:loaded_python3_provider = 0
let g:loaded_ruby_provider = 0
let g:loaded_perl_provider = 0
let g:loaded_node_provider = 0

let mapleader = " "
nnoremap <Space> <Nop>


" =============================================================================
" plugins
call plug#begin('~/.vim/bundle')

" -----------------------------------------------------------------------------
" generic
if ! has('nvim')
  Plug 'tpope/vim-sensible'
  Plug 'Shougo/vimproc.vim', {'do': 'make'}
endif
if has('nvim')
  Plug 'nvim-lua/plenary.nvim'
endif
Plug 'tpope/vim-repeat'

" -----------------------------------------------------------------------------
" editing
if has('nvim')
  Plug 'neovim/nvim-lspconfig'
  Plug 'williamboman/mason.nvim'
  Plug 'williamboman/mason-lspconfig.nvim'
  Plug 'hrsh7th/nvim-cmp'
  Plug 'hrsh7th/cmp-nvim-lsp'
  Plug 'hrsh7th/cmp-buffer'
  Plug 'hrsh7th/cmp-path'
  Plug 'hrsh7th/cmp-nvim-lsp-signature-help'
  Plug 'hrsh7th/cmp-cmdline'
  Plug 'L3MON4D3/LuaSnip'
  Plug 'saadparwaiz1/cmp_luasnip'
  Plug 'rafamadriz/friendly-snippets'
else
  Plug 'vim-scripts/AutoComplPop'
endif
if has('nvim')
  Plug 'windwp/nvim-autopairs'
else
  Plug 'Raimondi/delimitMate'
end
Plug 'alvan/vim-closetag'
Plug 'wellle/targets.vim'
if has('nvim')
  Plug 'kylechui/nvim-surround'
else
  Plug 'tpope/vim-surround'
endif
Plug 'romainl/vim-cool'
if ! has('nvim')
  Plug 'ConradIrwin/vim-bracketed-paste'
endif
Plug 'vim-scripts/file-line'
Plug 'pbrisbin/vim-mkdir'
Plug 'farmergreg/vim-lastplace'
if ! has('nvim')
  Plug 'moll/vim-bbye'
  Plug 'vim-scripts/BufOnly.vim'
endif
if has('nvim')
  Plug 'okuuva/auto-save.nvim'
else
  Plug '907th/vim-auto-save'
endif
if has('nvim')
  Plug 'ahmedkhalf/project.nvim'
endif
Plug 'tpope/vim-sleuth'
if has('nvim')
  Plug 'lewis6991/spaceless.nvim'
else
  Plug 'thirtythreeforty/lessspace.vim'
endif
Plug 'ntpeters/vim-better-whitespace'
if has('nvim')
  Plug 'gbprod/yanky.nvim'
else
  Plug 'maxbrunsfeld/vim-yankstack'
endif
if has('nvim')
  Plug 'jiaoshijie/undotree', {'as': 'undotree.nvim'}
else
  Plug 'mbbill/undotree'
endif
if has('nvim')
  Plug 'numToStr/Comment.nvim'
else
  Plug 'scrooloose/nerdcommenter'
endif
if has('nvim')
  Plug 'johmsalas/text-case.nvim'
  Plug 'Wansmer/treesj'
  Plug 'echasnovski/mini.align'
endif
if has('nvim')
  Plug 'ThePrimeagen/refactoring.nvim'
endif
if has('nvim')
  Plug 'stevearc/conform.nvim'
endif

" -----------------------------------------------------------------------------
" navigation
Plug 'reo7sp/vim-unimpaired'
Plug 'justinmk/vim-sneak'
Plug 'haya14busa/vim-asterisk'
if has('nvim')
  Plug 'nvim-telescope/telescope.nvim', {'tag': '0.1.8'}
  Plug 'nvim-telescope/telescope-fzf-native.nvim', {'do': 'make'}
  Plug 'smartpde/telescope-recent-files'
  Plug 'nvim-telescope/telescope-live-grep-args.nvim'
  Plug 'princejoogie/dir-telescope.nvim'
  Plug 'LukasPietzschmann/telescope-tabs'
  Plug 'jmacadie/telescope-hierarchy.nvim'
endif
if has('nvim')
  Plug 'folke/trouble.nvim'
endif
if has('nvim')
  Plug 'nvim-tree/nvim-tree.lua'
endif
if has('nvim')
  Plug 'stevearc/oil.nvim'
endif
if has('nvim')
  Plug 'stevearc/aerial.nvim'
endif
if has('nvim')
  Plug 'nvim-pack/nvim-spectre', {'on': 'Spectre', 'do': './build.sh nvim-oxi'}
endif

" -----------------------------------------------------------------------------
" appearance
if has('nvim')
  Plug 'rebelot/kanagawa.nvim'
else
  Plug 'sainnhe/sonokai'
end
if has('nvim')
  Plug 'nvim-lualine/lualine.nvim'
else
  Plug 'vim-airline/vim-airline'
endif
if has('nvim')
  Plug 'romgrk/barbar.nvim'
  Plug 'tiagovla/scope.nvim'
else
  Plug 'ap/vim-buftabline'
endif
if has('nvim')
  Plug 'j-hui/fidget.nvim'
endif
if has('nvim')
  Plug 'lewis6991/gitsigns.nvim'
  Plug 'akinsho/git-conflict.nvim'
else
  Plug 'airblade/vim-gitgutter'
endif
if has('nvim')
  Plug 'rachartier/tiny-inline-diagnostic.nvim'
  Plug 'RRethy/vim-illuminate'
  Plug 'lukas-reineke/indent-blankline.nvim'
  Plug 'lukas-reineke/virt-column.nvim'
  Plug 'psliwka/vim-smoothie'
endif
let g:polyglot_disabled = ['sensible', 'autoindent']
Plug 'sheerun/vim-polyglot'
if has('nvim')
  Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
  Plug 'nvim-treesitter/nvim-treesitter-textobjects'
endif
Plug 'Vimjas/vim-python-pep8-indent', {'for': 'python'}
Plug 'johejo/gomod.vim'
Plug 'HiPhish/jinja.vim'
Plug 'fladson/vim-kitty'

" -----------------------------------------------------------------------------
" commands
if has('nvim')
  Plug 'folke/which-key.nvim'
else
  Plug 'liuchengxu/vim-which-key'
endif
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive', {'on': ['Git', 'G', 'Flog', 'Flogsplit']}
Plug 'rbong/vim-flog', {'on': ['Git', 'G', 'Flog', 'Flogsplit']}
if has('nvim')
  Plug 'sindrets/diffview.nvim', {'on': ['DiffviewOpen', 'DiffviewFileHistory']}
endif

call plug#end()


" =============================================================================
" colors
if has('termguicolors')
  set termguicolors
endif

if ! has('nvim')
  " https://github.com/kovidgoyal/kitty/issues/108#issuecomment-320492663
  let &t_ut=''
endif

if has('nvim')
  lua require('kanagawa').setup({ compile = true, theme = 'dragon' })
  colorscheme kanagawa-dragon
else
  let g:sonokai_enable_italic = 1
  let g:sonokai_float_style = 'dim'
  let g:airline_theme = 'sonokai'
  colorscheme sonokai
endif


" =============================================================================
" plugin settings

" -----------------------------------------------------------------------------
" hrsh7th/nvim-cmp
function! InitNvimCmp() abort
  lua << EOF
  local lspconfig_defaults = require('lspconfig').util.default_config
  lspconfig_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lspconfig_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )

  require('mason').setup({})

  local custom = {
  };
  require('mason-lspconfig').setup({
    ensure_installed = {
      'gopls',
      'pyright',
      'perlnavigator',
      'lua_ls',
      'bashls',
      'cmake',
      'html',
      'cssls',
      'ts_ls',
      'jinja_lsp',
      'sqlls',
      'jsonls',
      'yamlls',
      'lemminx',
      'dockerls',
      'docker_compose_language_service',
      'nginx_language_server',
      'ansiblels',
      'puppet',
      'gitlab_ci_ls',
    },
    handlers = {
      function(server_name)
        require('lspconfig')[server_name].setup(custom[server_name] or {})
      end,
    },
  })

  require('luasnip.loaders.from_vscode').lazy_load()

  local cmp = require('cmp')
  local luasnip = require('luasnip')
  cmp.setup({
    sources = {
      { name = 'path' },
      { name = 'nvim_lsp' },
      { name = 'luasnip', keyword_length = 2 },
      { name = 'buffer', keyword_length = 3 },
      { name = 'nvim_lsp_signature_help' },
    },
    view = {
      entries = {
        follow_cursor = true,
      },
    },
    preselect = 'none',
    completion = {
      completeopt = 'menu,menuone,noinsert,noselect'
    },
    snippet = {
      expand = function(args)
        require('luasnip').lsp_expand(args.body)
      end,
    },
    mapping = cmp.mapping.preset.insert({
      --['<C-d>'] = cmp.mapping(cmp.mapping.scroll_docs(5), {'i', 'c'}),
      --['<C-u>'] = cmp.mapping(cmp.mapping.scroll_docs(-5), {'i', 'c'}),
      ['<C-d>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          for i = 1, 10, 1 do
            cmp.select_next_item()
          end
        else
          fallback()
        end
      end, { 'i', 's' }),
      ['<C-u>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          for i = 1, 10, 1 do
            cmp.select_prev_item()
          end
        else
          fallback()
        end
      end, { 'i', 's' }),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.close(),
      ['<CR>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          if luasnip.expandable() then
            luasnip.expand()
          else
            cmp.confirm({ select = true })
          end
        else
          fallback()
        end
      end),
      ['<Tab>'] = cmp.mapping(function(fallback)
        if cmp.visible() then
          local entry = cmp.get_selected_entry()
          if not entry then
            cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
          end
          cmp.confirm()
        elseif luasnip.expand_or_jumpable() then
          luasnip.expand_or_jump()
        else
          fallback()
        end
      end, { 'i', 's' }),
    }),
  })
  cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      {
        name = 'buffer',
      }
    }
  })
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      {
        name = 'path',
      }
    }, {
      {
        name = 'cmdline',
        option = {
          ignore_cmds = { 'Man', '!' }
        }
      }
    }),
    matching = { disallow_symbol_nonprefix_matching = false }
  })
EOF

  augroup NvimCmp
  autocmd!
  autocmd FileType TelescopePrompt lua require('cmp').setup.buffer({ enabled = false })
  augroup END

  nnoremap gd <cmd>Telescope lsp_definitions<cr>
  nnoremap gD <cmd>Telescope lsp_implementations<cr>
  nnoremap gi <cmd>Telescope lsp_implementations<cr>
  nnoremap gy <cmd>Telescope lsp_type_definitions<cr>
  nnoremap gr <cmd>Telescope lsp_references<cr>
  nnoremap gR <cmd>Telescope hierarchy<cr>
  nnoremap go <cmd>lua vim.lsp.buf.hover()<cr>
  nnoremap <leader>lr <cmd>lua vim.lsp.buf.rename()<cr>
  nnoremap <leader>lf <cmd>lua vim.lsp.buf.format({})<cr>
  xnoremap <leader>lf <cmd>lua vim.lsp.buf.format({})<cr>
  nnoremap <leader>lc <cmd>lua vim.lsp.buf.code_action()<cr>
  nnoremap [p <cmd>lua vim.diagnostic.goto_prev({float=false})<cr>
  nnoremap ]p <cmd>lua vim.diagnostic.goto_next({float=false})<cr>
endfunction

if has('nvim')
  call InitNvimCmp()
endif

" -----------------------------------------------------------------------------
" windwp/nvim-autopairs
function! InitAutopairs() abort
  lua require('nvim-autopairs').setup({})
endfunction

if has('nvim')
  call InitAutopairs()
endif

" -----------------------------------------------------------------------------
" kylechui/nvim-surround
function! InitNvimSurround() abort
  lua << EOF
  require('nvim-surround').setup({
    move_cursor = false,
  })
EOF
endfunction

if has('nvim')
  call InitNvimSurround()
endif

" -----------------------------------------------------------------------------
" moll/vim-bbye
function! InitBbye() abort
  cnoreabbrev bq Bdelete
  cnoreabbrev bd Bdelete
  nnoremap <C-q> <cmd>Bdelete<cr>
endfunction

if ! has('nvim')
  call InitBbye()
endif

" -----------------------------------------------------------------------------
" vim-scripts/BufOnly.vim
function! InitBufOnly() abort
  cnoreabbrev bo silent BufOnly
  cnoreabbrev bon silent BufOnly
  cnoreabbrev bonly silent BufOnly
endfunction

if ! has('nvim')
  call InitBufOnly()
endif

" -----------------------------------------------------------------------------
" okuuva/auto-save.nvim or 907th/vim-auto-save
function! InitAutosaveNvim() abort
  lua << EOF
  require('auto-save').setup({
    condition = function(buf)
      local filetype = vim.fn.getbufvar(buf, '&filetype')
      if vim.list_contains({ 'oil' }, filetype) then
        return false
      end
      return true
    end
  })
EOF
endfunction

function! InitAutosaveVim() abort
  let g:auto_save = 1
  let g:auto_save_silent = 1
endfunction

if has('nvim')
  call InitAutosaveNvim()
else
  call InitAutosaveVim()
endif

" -----------------------------------------------------------------------------
" ahmedkhalf/project.nvim
function! InitProjectNvim() abort
  lua << EOF
  require('project_nvim').setup({
    scope_chdir = 'tab',
    silent_chdir = false,
    patterns = {
      '.git',
      '_darcs',
      '.hg',
      '.bzr',
      '.svn',
      'package.json',
    },
  })
EOF
endfunction

if has('nvim')
  call InitProjectNvim()
endif

" -----------------------------------------------------------------------------
" ntpeters/vim-better-whitespace
function! InitBetterWhitespace() abort
  let g:better_whitespace_enabled = 0
  let g:better_whitespace_operator = ''
  let g:strip_max_file_size = 99999
  let g:strip_whitespace_confirm = 0

  nnoremap ]w <cmd>NextTrailingWhitespace<CR>
  nnoremap [w <cmd>PrevTrailingWhitespace<CR>
endfunction

call InitBetterWhitespace()

" -----------------------------------------------------------------------------
" gbprod/yanky.nvim or maxbrunsfeld/vim-yankstack
function! InitYanky() abort
  lua << EOF
  require('yanky').setup({
    ring = {
      storage = 'memory',
    },
    system_clipboard = {
      sync_with_ring = false,
    },
    preserve_cursor_position = {
      enabled = true,
    },
    textobj = {
      enabled = true,
    },
  })

  vim.keymap.set({ 'n', 'x' }, 'y', '<Plug>(YankyYank)')
  vim.keymap.set({ 'n', 'x' }, 'p', '<Plug>(YankyPutAfter)')
  vim.keymap.set({ 'n', 'x' }, 'P', '<Plug>(YankyPutBefore)')
  vim.keymap.set({ 'n', 'x' }, 'gp', '<Plug>(YankyGPutAfter)')
  vim.keymap.set({ 'n', 'x' }, 'gP', '<Plug>(YankyGPutBefore)')
  vim.keymap.set('n', '>p', '<Plug>(YankyPutIndentAfterShiftRight)')
  vim.keymap.set('n', '<p', '<Plug>(YankyPutIndentAfterShiftLeft)')
  vim.keymap.set('n', '>P', '<Plug>(YankyPutIndentBeforeShiftRight)')
  vim.keymap.set('n', '<P', '<Plug>(YankyPutIndentBeforeShiftLeft)')
  vim.keymap.set('n', '=p', '<Plug>(YankyPutAfterFilter)')
  vim.keymap.set('n', '=P', '<Plug>(YankyPutBeforeFilter)')
  vim.keymap.set({ 'o', 'x' }, 'iy', function() require('yanky.textobj').last_put() end, {})
  vim.keymap.set('n', '[y', '<Plug>(YankyPreviousEntry)')
  vim.keymap.set('n', ']y', '<Plug>(YankyNextEntry)')
EOF
endfunction

function! InitYankStack() abort
  let g:yankstack_map_keys = 0

  nnoremap ]y <Plug>yankstack_substitute_older_paste
  nnoremap [y <Plug>yankstack_substitute_newer_paste
endfunction

if has('nvim')
  call InitYanky()
else
  call InitYankStack()
endif

" -----------------------------------------------------------------------------
" jiaoshijie/undotree or mbbill/undotree
function! InitUndotreeNvim() abort
  lua << EOF
  require('undotree').setup({
    float_diff = false,
    layout = 'left_left_bottom',
  })
EOF

  nnoremap <leader>u <cmd>lua require('undotree').toggle()<cr>
endfunction

function! InitUndotreeVim() abort
  let g:undotree_DiffAutoOpen = 0
  let g:undotree_SetFocusWhenToggle = 1
  let g:undotree_SplitWidth = 40

  nnoremap <leader>u <cmd>UndotreeToggle<cr>
endfunction

if has('nvim')
  call InitUndotreeNvim()
else
  call InitUndotreeVim()
endif

" -----------------------------------------------------------------------------
" numToStr/Comment.nvim or scrooloose/nerdcommenter
function! InitComment() abort
  lua require('Comment').setup()

  nnoremap <C-/> <Plug>(comment_toggle_linewise_current)
  nnoremap <D-/> <Plug>(comment_toggle_linewise_current)
  xnoremap <C-/> <Plug>(comment_toggle_linewise_visual)
  xnoremap <D-/> <Plug>(comment_toggle_linewise_visual)
endfunction

function! InitNerdCommenter() abort
  nnoremap <C-/> <Plug>NERDCommenterToggle
  vnoremap <C-/> <Plug>NERDCommenterToggle<CR>gv
endfunction

if has('nvim')
  call InitComment()
else
  call InitNerdCommenter()
end

" -----------------------------------------------------------------------------
" johmsalas/text-case.nvim
function! InitTextCase() abort
  lua << EOF
  require('textcase').setup({
    prefix = 'gt',
  })
EOF
endfunction

if has('nvim')
  call InitTextCase()
endif

" -----------------------------------------------------------------------------
" Wansmer/treesj
function! InitTreeSJ() abort
  lua << EOF
  require('treesj').setup({
    use_default_keymaps = false,
    max_join_length = 9999,
  })
EOF

  nnoremap gs <cmd>lua require('treesj').toggle()<cr>
  nnoremap gS <cmd>lua require('treesj').toggle({ split = { recursive = true } })<cr>
endfunction

if has('nvim')
  call InitTreeSJ()
endif

" -----------------------------------------------------------------------------
" echasnovski/mini.align
function! InitMiniAlign() abort
  lua require('mini.align').setup()
endfunction

if has('nvim')
  call InitMiniAlign()
endif

" -----------------------------------------------------------------------------
" ThePrimeagen/refactoring.nvim
function! InitRefactoring() abort
  lua << EOF
  require('refactoring').setup({})

  vim.keymap.set({ 'n', 'x' }, '<leader>lR', function() require('refactoring').select_refactor() end, { desc = 'Refactor' })
EOF
endfunction

if has('nvim')
  call InitRefactoring()
endif

" -----------------------------------------------------------------------------
" stevearc/conform.nvim
function! InitConform() abort
  lua << EOF
  require('conform').setup({
    formatters_by_ft = {
      go = {
        'goimports',
        'gofmt',
      },
      python = {
        'isort',
        'black',
      },
    },
    default_format_opts = {
      lsp_format = 'fallback',
    },
  })
EOF

  nnoremap <leader>lF <cmd>lua require('conform').format({})<cr>
  xnoremap <leader>lF <cmd>lua require('conform').format({})<cr>
endfunction

if has('nvim')
  call InitConform()
endif

" -----------------------------------------------------------------------------
" justinmk/vim-sneak
function! InitSneak() abort
  let g:sneak#use_ic_scs = 1

  map f <Plug>Sneak_f
  map F <Plug>Sneak_F
  map t <Plug>Sneak_t
  map T <Plug>Sneak_T
endfunction

call InitSneak()

" -----------------------------------------------------------------------------
" haya14busa/vim-asterisk
function! InitAsterisk() abort
  map *   <Plug>(asterisk-*)
  map #   <Plug>(asterisk-#)
  map g*  <Plug>(asterisk-g*)
  map g#  <Plug>(asterisk-g#)
  map z*  <Plug>(asterisk-z*)
  map gz* <Plug>(asterisk-gz*)
  map z#  <Plug>(asterisk-z#)
  map gz# <Plug>(asterisk-gz#)
endfunction

call InitAsterisk()

" -----------------------------------------------------------------------------
" nvim-telescope/telescope.nvim
function! InitTelescope() abort
  lua << EOF
  require('telescope').setup({
    defaults = vim.tbl_extend(
      'force',
      require('telescope.themes').get_ivy(),
      {
        mappings = {
          i = {
            ['<c-t>'] = require('trouble.sources.telescope').open,
            ['<c-p>'] = require('telescope.actions.layout').toggle_preview,
            ['<C-Down>'] = require('telescope.actions').cycle_history_next,
            ['<C-Up>'] = require('telescope.actions').cycle_history_prev,
          },
          n = {
            ['<c-t>'] = require('trouble.sources.telescope').open,
            ['<c-p>'] = require('telescope.actions.layout').toggle_preview,
            ['<C-Down>'] = require('telescope.actions').cycle_history_next,
            ['<C-Up>'] = require('telescope.actions').cycle_history_prev,
          },
        },
        initial_mode = 'normal',
        dynamic_preview_title = true,
      }
    ),
    pickers = {
      buffers = {
        show_all_buffers = false,
        sort_buffers = function (a, b)
          local index_of = require('barbar.utils.list').index_of
          local state = require('barbar.state')
          return index_of(state.buffers, a) < index_of(state.buffers, b)
        end,
        select_current = true,
      },
      lsp_definitions = {
        fname_width = 60,
      },
      lsp_implementations = {
        fname_width = 60,
      },
      lsp_implementations = {
        fname_width = 60,
      },
      lsp_type_definitions = {
        fname_width = 60,
      },
      lsp_references = {
        fname_width = 60,
      },
      lsp_dynamic_workspace_symbols = {
        ignore_symbols = { 'variable', 'field' },
        fname_width = 60,
      },
    },
    extensions = {
      recent_files = {
        stat_files = false,
        only_cwd = true,
        show_current_file = true,
        ignore_patterns = {
          '/tmp/',
          'Scratch',
          'trouble',
          'NvimTree_',
          'oil',
          'aerial',
          'undotree',
          'spectre',
          'gitsigns',
          'fugitiveblame',
          'diffpanel_',
          'Plugins',
          'COMMIT_',
          '-todo$',
        },
      },
      live_grep_args = {
        mappings = {
          i = {
            ['<C-k>'] = require('telescope-live-grep-args.actions').quote_prompt(),
            ['<C-g>'] = require('telescope-live-grep-args.actions').quote_prompt({ postfix = ' --iglob ' }),
            ['<C-t>'] = require('telescope-live-grep-args.actions').quote_prompt({ postfix = ' --type ' }),
            ['<C-f>'] = require('telescope-live-grep-args.actions').quote_prompt({ postfix = ' -F ' }),
            ['<C-i>'] = require('telescope-live-grep-args.actions').quote_prompt({ postfix = ' --no-ignore ' }),
            ['<C-space>'] = require('telescope-live-grep-args.actions').to_fuzzy_refine,
          },
        },
      },
      hierarchy = {
        theme = 'ivy',
        disable_devicons = true,
      },
      aerial = {
        show_columns = 'symbols',
      },
    },
  })
  require('telescope').load_extension('fzf')
  require('telescope').load_extension('recent_files')
  require('telescope').load_extension('live_grep_args')
  require('telescope').load_extension('dir')
  require('telescope').load_extension('telescope-tabs')
  require('telescope-tabs').setup({})
  require('telescope').load_extension('yank_history')
  require('telescope').load_extension('aerial')
  require('telescope').load_extension('hierarchy')
EOF

  nnoremap <leader>e <cmd>lua require('telescope').extensions.recent_files.pick()<cr>
  nnoremap <leader>f <cmd>Telescope find_files<cr>i
  nnoremap <leader>s <cmd>Telescope live_grep_args<cr>i
  vnoremap <leader>s <cmd>lua require('telescope-live-grep-args.shortcuts').grep_visual_selection()<cr>
  nnoremap <leader>Ff <cmd>Telescope dir find_files<cr>i
  nnoremap <leader>Fs <cmd>Telescope dir live_grep<cr>i
  nnoremap <leader>b <cmd>Telescope buffers<cr>
  nnoremap <leader>B <cmd>Telescope telescope-tabs list_tabs<cr>
  nnoremap <leader>E <cmd>Telescope jumplist<cr>
  nnoremap <leader>y <cmd>Telescope yank_history<cr>
  nnoremap <leader>k <cmd>Telescope aerial<cr>
  nnoremap <leader>K <cmd>Telescope lsp_dynamic_workspace_symbols<cr>i
endfunction

if has('nvim')
  call InitTelescope()
endif

" -----------------------------------------------------------------------------
" folke/trouble.nvim
function! InitTrouble() abort
  lua << EOF
  require('trouble').setup({
    focus = true,
    auto_preview = false,
    auto_jump = false,
    follow = false,
    win = {
      size = 0.4,
    },
    icons = {
      indent = {
        fold_open     = "  ",
        fold_closed   = "│ ",
      },
      folder_closed   = "",
      folder_open     = "",
      kinds = {
        Array         = "",
        Boolean       = "",
        Class         = "",
        Constant      = "",
        Constructor   = "",
        Enum          = "",
        EnumMember    = "",
        Event         = "",
        Field         = "",
        File          = "",
        Function      = "",
        Interface     = "",
        Key           = "",
        Method        = "",
        Module        = "",
        Namespace     = "",
        Null          = "",
        Number        = "",
        Object        = "",
        Operator      = "",
        Package       = "",
        Property      = "",
        String        = "",
        Struct        = "",
        TypeParameter = "",
        Variable      = "",
      },
    },
  })

  vim.api.nvim_create_autocmd("QuickFixCmdPost", {
    callback = function()
      vim.cmd([[Trouble qflist open]])
    end,
  })
EOF

  nnoremap <leader>gd <cmd>Trouble lsp_definitions toggle<CR>
  nnoremap <leader>gD <cmd>Trouble lsp_implementations toggle<CR>
  nnoremap <leader>gi <cmd>Trouble lsp_implementations toggle<CR>
  nnoremap <leader>gy <cmd>Trouble lsp_type_definitions toggle<CR>
  nnoremap <leader>gr <cmd>Trouble lsp_references toggle<CR>
  nnoremap <leader>p <cmd>Trouble diagnostics toggle filter.buf=0<CR>
endfunction

if has('nvim')
  call InitTrouble()
endif

" -----------------------------------------------------------------------------
" nvim-tree/nvim-tree.lua
function! InitLazyNvimTree() abort
  lua << EOF
  local api = require("nvim-tree.api")
  local openfile = require'nvim-tree.actions.node.open-file'
  local actions = require'telescope.actions'
  local action_state = require'telescope.actions.state'
  local M = {}

  local view_selection = function(prompt_bufnr, map)
    actions.select_default:replace(function()
      actions.close(prompt_bufnr)
      local selection = action_state.get_selected_entry()
      local filename = selection.filename
      if (filename == nil) then
        filename = selection[1]
      end
      openfile.fn('preview', filename)
    end)
    return true
  end

  function M.launch_live_grep(opts)
    return M.launch_telescope("live_grep", opts)
  end

  function M.launch_find_files(opts)
    return M.launch_telescope("find_files", opts)
  end

  function M.launch_telescope(func_name, opts)
    local telescope_status_ok, _ = pcall(require, "telescope")
    if not telescope_status_ok then
      return
    end
    local node = api.tree.get_node_under_cursor()
    local is_folder = node.fs_stat and node.fs_stat.type == 'directory' or false
    local basedir = is_folder and node.absolute_path or vim.fn.fnamemodify(node.absolute_path, ":h")
    if (node.name == '..' and TreeExplorer ~= nil) then
      basedir = TreeExplorer.cwd
    end
    opts = opts or {}
    opts.cwd = basedir
    opts.search_dirs = { basedir }
    opts.attach_mappings = view_selection
    require("telescope.builtin")[func_name](opts)
    vim.api.nvim_feedkeys('i', 'n', false)
  end

  require('nvim-tree').setup({
    renderer = {
      icons = {
        show = {
          file = false,
          folder = false,
          folder_arrow = false,
          git = false,
          modified = false,
          hidden = false,
          diagnostics = false,
          bookmarks = true,
        },
        glyphs = {
          bookmark = 'M',
        },
      },
      indent_markers = {
        enable = true,
      },
    },
    view = {
      width = 40,
    },
    git = {
      enable = false,
    },
    sync_root_with_cwd = true,
    respect_buf_cwd = true,
    update_focused_file = {
      enable = true,
      update_root = true,
    },
    filters = {
      enable = true,
      git_ignored = true,
      dotfiles = false,
      custom = { '^.git$' },
    },
    actions = {
      open_file = {
        quit_on_open = false,
        window_picker = {
          enable = false,
        },
      },
    },
    on_attach = function (bufnr)
      local api = require('nvim-tree.api')

      local function opts(desc)
        return { desc = 'nvim-tree: ' .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
      end

      api.config.mappings.default_on_attach(bufnr)

      vim.keymap.set('n', '<c-f>', M.launch_find_files, opts('Launch Find Files'))
      vim.keymap.set('n', '<c-s>', M.launch_live_grep,  opts('Launch Live Grep'))
    end,
  })
EOF
endfunction

function! LazyNvimTreeToggle() abort
  if ! exists('g:inited_nvim_tree')
    call InitLazyNvimTree()
    let g:inited_nvim_tree = 1
  endif

  NvimTreeToggle
endfunction

function! LazyNvimTreeOpen() abort
  if ! exists('g:inited_nvim_tree')
    call InitLazyNvimTree()
    let g:inited_nvim_tree = 1
  endif

  NvimTreeOpen
endfunction

function! InitNvimTree() abort
  nnoremap <leader>t <cmd>call LazyNvimTreeToggle()<CR>
  nnoremap <leader><Space> <cmd>call LazyNvimTreeOpen()<CR>
  nnoremap <C-\> <cmd>call LazyNvimTreeToggle()<CR>
  nnoremap <D-\> <cmd>call LazyNvimTreeToggle()<CR>
endfunction

if has('nvim')
  call InitNvimTree()
endif

" -----------------------------------------------------------------------------
" stevearc/oil.nvim
function! InitOil() abort
  lua require('oil').setup()

  nnoremap <leader>T <cmd>Oil<CR>
endfunction

if has('nvim')
  call InitOil()
endif

" -----------------------------------------------------------------------------
" stevearc/aerial.nvim
function! InitAerial() abort
  lua << EOF
  require('aerial').setup({
    layout = {
      default_direction = 'left',
      min_width = 40,
      width = 40,
    },
    close_on_select = false,
    autojump = true,
    show_guides = true,
  })
EOF

  nnoremap <leader>o <cmd>AerialToggle<cr>
endfunction

if has('nvim')
  call InitAerial()
endif

" -----------------------------------------------------------------------------
" nvim-pack/nvim-spectre
function! InitLazySpectre() abort
  lua << EOF
  require('spectre').setup({
    use_trouble_qf = true,
    is_block_ui_break = true,
    is_insert_mode = false,
    default = {
      replace = {
        cmd = 'oxi',
      },
    },
  })
EOF
endfunction

function! LazySpectreVisualFromYank() abort
  call plug#load('nvim-spectre')
  lua require('spectre').open({ search_text = vim.fn.getreg('0') })
endfunction

function! InitSpectre() abort
  nnoremap <leader>S <cmd>Spectre<cr>
  vnoremap <leader>S y<cmd>call LazySpectreVisualFromYank()<cr>
endfunction

if has('nvim')
  autocmd User nvim-spectre call InitLazySpectre()
  call InitSpectre()
endif

" -----------------------------------------------------------------------------
" nvim-lualine/lualine.nvim or vim-airline/vim-airline
function! InitLualine() abort
  lua << EOF
  local function diff_source()
    local gitsigns = vim.b.gitsigns_status_dict
    if gitsigns then
      return {
        added = gitsigns.added,
        modified = gitsigns.changed,
        removed = gitsigns.removed
      }
    end
  end

  local lualine = require('lualine')
  lualine.setup({
    options = {
      icons_enabled = false,
      component_separators = { left = '', right = '' },
      section_separators = { left = '', right = '' },
    },
    extensions = {
      'trouble',
      'nvim-tree',
      'oil',
      'aerial',
      'fugitive',
      'quickfix',
    },
    sections = {
      lualine_a = {
        { 'mode', fmt = function(str) return str:sub(1, 1) end },
      },
      lualine_b = {
      },
      lualine_c = {
        { 'filename', path = 1, file_status = false },
        { 'aerial', depth = 3, sep = ' > ', padding = { left = 0, right = 1 } },
      },
      lualine_x = {
        'b:gitsigns_head',
        { 'diff', source = diff_source, padding = { left = 0, right = 1 } },
      },
      lualine_y = {
        'filetype',
        { 'lsp_status', symbols = { done = '' }, padding = { left = 0, right = 1 } },
        { 'diagnostics', padding = { left = 0, right = 1 } },
      },
      lualine_z = {
        'location',
        'searchcount',
        'selectioncount',
      },
    },
    inactive_sections = {
      lualine_a = {
      },
      lualine_b = {
      },
      lualine_c = {
        { 'filename', path = 1, file_status = false },
      },
      lualine_x = {
        'location',
      },
      lualine_y = {
      },
      lualine_z = {
      },
    },
  })
EOF
endfunction

function! InitAirline() abort
  if !exists('g:airline_symbols')
    let g:airline_symbols = {}
  endif
  let g:airline_symbols.branch = '⎇'
  let g:airline_symbols.paste = 'ρ'
  let g:airline_symbols.readonly = '∥'
  let g:airline_symbols.whitespace = 'Ξ'
  let g:airline_symbols.linenr = ''
  let g:airline_symbols.maxlinenr = ''
  let g:airline_symbols.colnr = ':'

  let g:airline_skip_empty_sections = 1
  autocmd User AirlineAfterInit :let g:airline_section_y = ''
  autocmd User AirlineAfterInit :let g:airline_section_z = airline#section#create(['linenr', 'colnr'])

  let g:airline#extensions#whitespace#enabled = 0
endfunction

if has('nvim')
  call InitLualine()
else
  call InitAirline()
endif

" -----------------------------------------------------------------------------
" romgrk/barbar.nvim or ap/vim-buftabline
function! InitBarbar() abort
  lua << EOF
  require('scope').setup({})

  vim.g.barbar_auto_setup = false
  require('barbar').setup({
    insert_at_end = true,
    focus_on_close = 'left',
    animation = false,
    icons = {
      button = false,
      filetype = {
        enabled = false,
      },
      gitsigns = {
        enabled = false,
      },
      modified = {
        button = '',
      },
      separator_at_end = false,
    },
    sidebar_filetypes = {},
    no_name_title = '[No Name]',
  })
EOF

  highlight BufferCurrentMod ctermfg=255 guifg=#c8c093 guibg=#282727
  highlight BufferInactiveMod ctermfg=255 guifg=#7a8382 guibg=#0d0c0c

  cnoreabbrev bq BufferClose
  cnoreabbrev bd BufferClose
  nnoremap <C-q> <cmd>BufferClose<cr>

  cnoreabbrev bo BufferCloseAllButCurrent
  cnoreabbrev bon BufferCloseAllButCurrent
  cnoreabbrev bonly BufferCloseAllButCurrent

  nnoremap <C-[> <cmd>BufferPrevious<CR>
  nnoremap <C-]> <cmd>BufferNext<CR>
  nnoremap <silent> [b <cmd>BufferPrevious<CR>
  nnoremap <silent> ]b <cmd>BufferNext<CR>

  nnoremap <C-1> <cmd>BufferGoto 1<CR>
  nnoremap <C-2> <cmd>BufferGoto 2<CR>
  nnoremap <C-3> <cmd>BufferGoto 3<CR>
  nnoremap <C-4> <cmd>BufferGoto 4<CR>
  nnoremap <C-5> <cmd>BufferGoto 5<CR>
  nnoremap <C-6> <cmd>BufferGoto 6<CR>
  nnoremap <C-7> <cmd>BufferGoto 7<CR>
  nnoremap <C-8> <cmd>BufferGoto 8<CR>
  nnoremap <C-9> <cmd>BufferLast<CR>

  cnoreabbrev bql BufferCloseBuffersLeft
  cnoreabbrev bdl BufferCloseBuffersLeft
  cnoreabbrev bqr BufferCloseBuffersRight
  cnoreabbrev bdr BufferCloseBuffersRight

  cnoreabbrev bs BufferOrderByDirectory

  nnoremap <C-,> <cmd>BufferMovePrevious<CR>
  nnoremap <C-.> <cmd>BufferMoveNext<CR>
endfunction

function! InitBuftablineVim() abort
  nnoremap <C-[> :bp<CR>
  nnoremap <C-]> :bn<CR>

  nnoremap <C-1> <Plug>BufTabLine.Go(1)
  nnoremap <C-2> <Plug>BufTabLine.Go(2)
  nnoremap <C-3> <Plug>BufTabLine.Go(3)
  nnoremap <C-4> <Plug>BufTabLine.Go(4)
  nnoremap <C-5> <Plug>BufTabLine.Go(5)
  nnoremap <C-6> <Plug>BufTabLine.Go(6)
  nnoremap <C-7> <Plug>BufTabLine.Go(7)
  nnoremap <C-8> <Plug>BufTabLine.Go(8)
  nnoremap <C-9> <Plug>BufTabLine.Go(-1)
endfunction

if has('nvim')
  call InitBarbar()
else
  call InitBuftablineVim()
endif

" -----------------------------------------------------------------------------
" j-hui/fidget.nvim
function! InitFidget() abort
  lua << EOF
  require('fidget').setup({})

  vim.notify = require('fidget').notify
EOF
endfunction

if has('nvim')
  call InitFidget()
endif

" -----------------------------------------------------------------------------
" lewis6991/gitsigns.nvim
function! InitGitSigns() abort
  lua << EOF
  require('gitsigns').setup({
    on_attach = function(bufnr)
      local gitsigns = require('gitsigns')
      local function map(mode, l, r, opts)
        opts = opts or {}
        opts.buffer = bufnr
        vim.keymap.set(mode, l, r, opts)
      end
      map('n', ']h', function()
        if vim.wo.diff then
          vim.cmd.normal({']h', bang = true})
        else
          gitsigns.nav_hunk('next')
        end
      end)
      map('n', '[h', function()
        if vim.wo.diff then
          vim.cmd.normal({'[h', bang = true})
        else
          gitsigns.nav_hunk('prev')
        end
      end)

      vim.keymap.set({ 'o', 'x' }, 'ih', '<cmd>Gitsigns select_hunk<CR>')
    end
  })
EOF

  nnoremap gh <cmd>Gitsigns blame_line<CR>
  nnoremap <leader>h <cmd>Gitsigns blame<CR>
endfunction

if has('nvim')
  call InitGitSigns()
endif

" -----------------------------------------------------------------------------
" kinsho/git-conflict.nvim
function! InitGitConflict() abort
  lua require('git-conflict').setup()
endfunction

if has('nvim')
  call InitGitConflict()
endif

" -----------------------------------------------------------------------------
" rachartier/tiny-inline-diagnostic.nvim
function! InitTinyDiag() abort
  lua << EOF
  require('tiny-inline-diagnostic').setup({})

  vim.diagnostic.config({ virtual_text = false })
EOF
endfunction

if has('nvim')
  call InitTinyDiag()
endif

" -----------------------------------------------------------------------------
" RRethy/vim-illuminate
function! InitIlluminate() abort
  lua << EOF
  require('illuminate').configure({
    disable_keymaps = true,
    filetypes_denylist = {
      'TelescopePrompt',
      'trouble',
      'NvimTree',
      'oil',
      'aerial',
      'undotree',
      'fugitiveblame',
    },
  })
EOF
endfunction

if has('nvim')
  call InitIlluminate()
endif

" -----------------------------------------------------------------------------
" lukas-reineke/indent-blankline.nvim
function! InitIndentBlankline() abort
  lua << EOF
  require('ibl').setup({
    indent = {
      char = '▏',
    },
    scope = {
      enabled = false,
    },
  })
EOF
endfunction

if has('nvim')
  call InitIndentBlankline()
endif

" -----------------------------------------------------------------------------
" lukas-reineke/virt-column.nvim
function! InitVirtColumn() abort
  lua << EOF
  require('virt-column').setup({
    char = '║',
  })
EOF
endfunction

if has('nvim')
  call InitVirtColumn()
endif

" -----------------------------------------------------------------------------
" psliwka/vim-smoothie
function! InitSmoothie() abort
  let g:smoothie_speed_constant_factor = 15
  let g:smoothie_speed_linear_factor = 15
endfunction

if has('nvim')
  call InitSmoothie()
endif

" -----------------------------------------------------------------------------
" nvim-treesitter/nvim-treesitter
function! InitTreesitter() abort
  lua << EOF
  require('nvim-treesitter.configs').setup({
    ensure_installed = {
      'c',
      'go',
      'python',
      'perl',
      'ruby',
      'lua',
      'bash',
      'html',
      'css',
      'javascript',
      'typescript',
      'tsx',
      'jinja',
      'sql',
      'json',
      'yaml',
      'xml',
      'vim',
      'markdown',
      'diff',
      'git_rebase',
    },
    sync_install = false,
    auto_install = true,
    highlight = {
      enable = true,
      disable = {
        'mermaid',
      },
    },
    indent = {
      enable = false,
    },
    textobjects = {
      select = {
        enable = true,
        lookahead = true,
        keymaps = {
          ["aa"] = { query = "@parameter.outer", desc = "Select outer part of a parameter/argument" },
          ["ia"] = { query = "@parameter.inner", desc = "Select inner part of a parameter/argument" },
          ["ai"] = { query = "@conditional.outer", desc = "Select outer part of a conditional" },
          ["ii"] = { query = "@conditional.inner", desc = "Select inner part of a conditional" },
          ["al"] = { query = "@loop.outer", desc = "Select outer part of a loop" },
          ["il"] = { query = "@loop.inner", desc = "Select inner part of a loop" },
          ["af"] = { query = "@call.outer", desc = "Select outer part of a function call" },
          ["if"] = { query = "@call.inner", desc = "Select inner part of a function call" },
          ["am"] = { query = "@function.outer", desc = "Select outer part of a method/function definition" },
          ["im"] = { query = "@function.inner", desc = "Select inner part of a method/function definition" },
          ["ac"] = { query = "@class.outer", desc = "Select outer part of a class" },
          ["ic"] = { query = "@class.inner", desc = "Select inner part of a class" },
        },
      },
      swap = {
        enable = true,
        swap_next = {
          ["cm"] = "@parameter.inner",
        },
      },
      move = {
        enable = true,
        set_jumps = true,
        goto_next_start = {
          ["]f"] = { query = "@call.outer", desc = "Next function call start" },
          ["]m"] = { query = "@function.outer", desc = "Next method/function def start" },
          ["]c"] = { query = "@class.outer", desc = "Next class start" },
          ["]i"] = { query = "@conditional.outer", desc = "Next conditional start" },
          ["]l"] = { query = "@loop.outer", desc = "Next loop start" },
        },
        goto_next_end = {
          ["]F"] = { query = "@call.outer", desc = "Next function call end" },
          ["]M"] = { query = "@function.outer", desc = "Next method/function def end" },
          ["]C"] = { query = "@class.outer", desc = "Next class end" },
          ["]I"] = { query = "@conditional.outer", desc = "Next conditional end" },
          ["]L"] = { query = "@loop.outer", desc = "Next loop end" },
        },
        goto_previous_start = {
          ["[f"] = { query = "@call.outer", desc = "Prev function call start" },
          ["[m"] = { query = "@function.outer", desc = "Prev method/function def start" },
          ["[c"] = { query = "@class.outer", desc = "Prev class start" },
          ["[i"] = { query = "@conditional.outer", desc = "Prev conditional start" },
          ["[l"] = { query = "@loop.outer", desc = "Prev loop start" },
        },
        goto_previous_end = {
          ["[F"] = { query = "@call.outer", desc = "Prev function call end" },
          ["[M"] = { query = "@function.outer", desc = "Prev method/function def end" },
          ["[C"] = { query = "@class.outer", desc = "Prev class end" },
          ["[I"] = { query = "@conditional.outer", desc = "Prev conditional end" },
          ["[L"] = { query = "@loop.outer", desc = "Prev loop end" },
        },
      },
    },
  })
EOF
endfunction

if has('nvim')
  call InitTreesitter()
endif

" -----------------------------------------------------------------------------
" folke/which-key.nvim or liuchengxu/vim-which-key
function! InitWhichKeyNvim() abort
  lua << EOF
  require('which-key').setup({
    delay = function(ctx)
      return ctx.plugin and 0 or 500
    end,
    layout = {
      width = { min = 25, max = 80 },
    },
    icons = {
      mappings = false,
      keys = {
        Up = "<Up>",
        Down = "<Down>",
        Left = "<Left>",
        Right = "<Right>",
        C = "<C>",
        M = "<M>",
        D = "<D>",
        S = "<S>",
        CR = "<CR>",
        Esc = "<Esc>",
        ScrollWheelDown = "<ScrollWheelDown>",
        ScrollWheelUp = "<ScrollWheelUp>",
        NL = "<NL>",
        BS = "<BS>",
        Space = "<Space>",
        Tab = "<Tab>",
        F1 = "<F1>",
        F2 = "<F2>",
        F3 = "<F3>",
        F4 = "<F4>",
        F5 = "<F5>",
        F6 = "<F6>",
        F7 = "<F7>",
        F8 = "<F8>",
        F9 = "<F9>",
        F10 = "<F10>",
        F11 = "<F11>",
        F12 = "<F12>",
      },
    },
  })
EOF

  nnoremap <leader>? <cmd>WhichKey<cr>
endfunction

function! InitWhichKeyVim() abort
  nnoremap <leader>? :WhichKey
endfunction

if has('nvim')
  call InitWhichKeyNvim()
else
  call InitWhichKeyVim()
endif

" -----------------------------------------------------------------------------
" sindrets/diffview.nvim
function! InitLazyDiffview() abort
  lua << EOF
  require('diffview').setup({
    use_icons = false,
    icons = {
      folder_closed = "",
      folder_open = "",
    },
    signs = {
      fold_closed = "",
      fold_open = "",
    },
  })
EOF
endfunction

if has('nvim')
  autocmd User diffview.nvim call InitLazyDiffview()
endif


" =============================================================================
" own commands

" -----------------------------------------------------------------------------
" yank file line reference
command YankFilename redir @+ | echo substitute(expand('%'), getcwd() . '/', '', '') | redir END
command YankReference redir @+ | echo join([substitute(expand('%'), getcwd() . '/', '', ''), line('.')], ':') | redir END

" -----------------------------------------------------------------------------
" sublime text & sublime merge integration
if has('nvim')
  lua << EOF
  vim.api.nvim_create_user_command('Subl',
    function (opts)
      if opts.fargs[1] == 'dir' then
        vim.cmd('!subl ' .. vim.fn.getcwd())
      else
        vim.cmd('!subl %')
      end
    end,
    {
      desc = 'Open in Sublime Text',
      nargs = '?',
      complete = function ()
        return {'dir'}
      end,
    }
  )

  vim.api.nvim_create_user_command('Smerge',
    function (opts)
      if opts.fargs[1] == 'blame' then
        vim.cmd('!smerge blame %')
      elseif opts.fargs[1] == 'log' then
        vim.cmd('!smerge log %')
      else
        vim.cmd('!smerge ' .. vim.fn.getcwd())
      end
    end,
    {
      desc = 'Open in Sublime Merge',
      nargs = '?',
      complete = function ()
        return {'dir', 'blame', 'log'}
      end,
    }
  )
EOF
endif


" =============================================================================
" vim mappings
" https://nanotipsforvim.prose.sh/esc-in-normal-mode
nnoremap <silent> <esc><esc> <cmd>echo<cr>

" https://bluz71.github.io/2021/09/10/vim-tips-revisited.html#smarter-j-and-k-navigation
nnoremap <silent> <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <silent> <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" https://superuser.com/a/836924/2151180
nnoremap <silent> } :<C-u>execute "keepjumps norm! " . v:count1 . "}"<CR>
nnoremap <silent> { :<C-u>execute "keepjumps norm! " . v:count1 . "{"<CR>

" https://vi.stackexchange.com/a/35
nnoremap gV `[v`]

" https://neovim.io/doc/user/cmdline.html#cmdline-editing
cnoremap <C-A> <Home>
cnoremap <C-F> <Right>
cnoremap <C-B> <Left>

" https://bluz71.github.io/2021/09/10/vim-tips-revisited.html#fast-previous-buffer-switching
nnoremap <C-Backspace> <C-^>
nnoremap <C-S-Backspace> <cmd>lua require('telescope-tabs').go_to_previous()<cr>

cnoreabbrev E e
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev Wqa wqa
cnoreabbrev w!! w !sudo tee % >/dev/null

cnoreabbrev tabq tabclose
cnoreabbrev tnew tabnew
cnoreabbrev tq tabclose

nnoremap <C-Up> <cmd>resize +2<cr>
nnoremap <C-Down> <cmd>resize -2<cr>
nnoremap <C-Right> <cmd>vertical resize +2<cr>
nnoremap <C-Left> <cmd>vertical resize -2<cr>

nnoremap +y "+y
nnoremap +Y "+Y
nnoremap +p "+p
nnoremap +P "+P
vnoremap +y "+y
vnoremap +Y "+Y
vnoremap +p "+p
vnoremap +P "+P

nnoremap <C-S> :w<CR>
inoremap <C-S> <Esc>:w<CR>l
vnoremap <C-S> <Esc>:w<CR>


" =============================================================================
" vim settings

" -----------------------------------------------------------------------------
" appearance
set number
set relativenumber
set cursorline
set colorcolumn=80,120
set scrolloff=3
set sidescroll=1

set nowrap

set mouse=a

set shortmess+=aITF
if has('patch-7.4.314')
  set shortmess+=c
endif
set noshowmode
set title
if has('nvim')
  set titlestring=%{substitute(getcwd(),$HOME,'~','')}\ -\ NVIM
else
  set titlestring=%{substitute(getcwd(),$HOME,'~','')}\ -\ VIM
endif
set confirm
if exists('+signcolumn')
  set signcolumn=yes
endif
set breakindent
set breakindentopt=sbr
set showbreak=↪
let g:vimsyn_embed = 'l'

" -----------------------------------------------------------------------------
" editing
set shiftwidth=4
set tabstop=4
set softtabstop=4
set expandtab

set autoindent
set copyindent
set smartindent
set fixendofline
if v:version >= 802
  set nrformats+=unsigned
endif

set nospell

set completeopt=menu,menuone,preview
set foldlevelstart=99
set foldmethod=syntax
if has('nvim')
  lua << EOF
  vim.api.nvim_create_autocmd({ "FileType" }, {
    callback = function()
      if require("nvim-treesitter.parsers").has_parser() then
        vim.opt.foldmethod = "expr"
        vim.opt.foldexpr = "nvim_treesitter#foldexpr()"
      else
        vim.opt.foldmethod = "syntax"
      end
    end,
  })
EOF
endif
set whichwrap+=b,s,h,l,<,>
set updatetime=300

set splitright
set splitbelow

set hidden
set autoread
set autowriteall
set undofile
set nobackup
set nowritebackup
set noswapfile

" -----------------------------------------------------------------------------
" navigation
set ignorecase
set smartcase
set hlsearch

" -----------------------------------------------------------------------------
" encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,cp1251,latin1
set fileformats=unix,dos,mac

" -----------------------------------------------------------------------------
" other
" https://superuser.com/questions/1642954/how-to-start-vim-with-a-clean-jumplist
autocmd VimEnter * :clearjumps

set backupdir=~/.vim/backup
set directory=~/.vim/tmp
set undodir=~/.vim/undo
set viewdir=~/.vim/view
if &shell =~# 'fish$'
  set shell=/bin/bash
endif


" =============================================================================
" neovide
if exists('g:neovide')
  language en_US
  language messages en_US
  language ctype en_US
  language time en_US
  set langmenu=en_US
  let $LANG = 'en_US'

  set guifont=Jetbrains\ Mono:h14:#e-subpixelantialias:#h-none
  set linespace=1

  lua << EOF
  vim.g.neovide_hide_mouse_when_typing = true
  vim.g.neovide_position_animation_length = 0
  vim.g.neovide_cursor_animation_length = 0.00
  vim.g.neovide_cursor_trail_size = 0
  vim.g.neovide_cursor_animate_in_insert_mode = false
  vim.g.neovide_cursor_animate_command_line = false
  vim.g.neovide_scroll_animation_far_lines = 0
  vim.g.neovide_scroll_animation_length = 0.00
EOF
endif
if has('nvim')
  lua << EOF
  vim.keymap.set('n', '<D-s>', ':w<CR>')
  vim.keymap.set('n', '<D-w>', ':wq<CR>')
  vim.keymap.set('v', '<D-c>', '"+y')
  vim.keymap.set('n', '<D-v>', '"+P')
  vim.keymap.set('v', '<D-v>', '"+P')
  vim.keymap.set('c', '<D-v>', '<C-R>+')
  vim.keymap.set('i', '<D-v>', '<ESC>l"+Pli')
  vim.api.nvim_set_keymap('', '<D-v>', '+p<CR>', { noremap = true, silent = true })
  vim.api.nvim_set_keymap('!', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  vim.api.nvim_set_keymap('t', '<D-v>', '<C-R>+', { noremap = true, silent = true })
  vim.api.nvim_set_keymap('v', '<D-v>', '<C-R>+', { noremap = true, silent = true })
EOF
endif
